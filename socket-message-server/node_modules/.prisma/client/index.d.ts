
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model call
 * 
 */
export type call = $Result.DefaultSelection<Prisma.$callPayload>
/**
 * Model callcenteragent
 * 
 */
export type callcenteragent = $Result.DefaultSelection<Prisma.$callcenteragentPayload>
/**
 * Model car
 * 
 */
export type car = $Result.DefaultSelection<Prisma.$carPayload>
/**
 * Model customer
 * 
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model driver
 * 
 */
export type driver = $Result.DefaultSelection<Prisma.$driverPayload>
/**
 * Model drivershift
 * 
 */
export type drivershift = $Result.DefaultSelection<Prisma.$drivershiftPayload>
/**
 * Model message
 * 
 */
export type message = $Result.DefaultSelection<Prisma.$messagePayload>
/**
 * Model rating
 * 
 */
export type rating = $Result.DefaultSelection<Prisma.$ratingPayload>
/**
 * Model ride
 * 
 */
export type ride = $Result.DefaultSelection<Prisma.$ridePayload>
/**
 * Model ridestatus
 * 
 */
export type ridestatus = $Result.DefaultSelection<Prisma.$ridestatusPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Calls
 * const calls = await prisma.call.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Calls
   * const calls = await prisma.call.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.call`: Exposes CRUD operations for the **call** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calls
    * const calls = await prisma.call.findMany()
    * ```
    */
  get call(): Prisma.callDelegate<ExtArgs>;

  /**
   * `prisma.callcenteragent`: Exposes CRUD operations for the **callcenteragent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Callcenteragents
    * const callcenteragents = await prisma.callcenteragent.findMany()
    * ```
    */
  get callcenteragent(): Prisma.callcenteragentDelegate<ExtArgs>;

  /**
   * `prisma.car`: Exposes CRUD operations for the **car** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cars
    * const cars = await prisma.car.findMany()
    * ```
    */
  get car(): Prisma.carDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.driverDelegate<ExtArgs>;

  /**
   * `prisma.drivershift`: Exposes CRUD operations for the **drivershift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivershifts
    * const drivershifts = await prisma.drivershift.findMany()
    * ```
    */
  get drivershift(): Prisma.drivershiftDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.messageDelegate<ExtArgs>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.ratingDelegate<ExtArgs>;

  /**
   * `prisma.ride`: Exposes CRUD operations for the **ride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rides
    * const rides = await prisma.ride.findMany()
    * ```
    */
  get ride(): Prisma.rideDelegate<ExtArgs>;

  /**
   * `prisma.ridestatus`: Exposes CRUD operations for the **ridestatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ridestatuses
    * const ridestatuses = await prisma.ridestatus.findMany()
    * ```
    */
  get ridestatus(): Prisma.ridestatusDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.11.0
   * Query Engine version: efd2449663b3d73d637ea1fd226bafbcf45b3102
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    call: 'call',
    callcenteragent: 'callcenteragent',
    car: 'car',
    customer: 'customer',
    driver: 'driver',
    drivershift: 'drivershift',
    message: 'message',
    rating: 'rating',
    ride: 'ride',
    ridestatus: 'ridestatus',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'call' | 'callcenteragent' | 'car' | 'customer' | 'driver' | 'drivershift' | 'message' | 'rating' | 'ride' | 'ridestatus' | 'user'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      call: {
        payload: Prisma.$callPayload<ExtArgs>
        fields: Prisma.callFieldRefs
        operations: {
          findUnique: {
            args: Prisma.callFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.callFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callPayload>
          }
          findFirst: {
            args: Prisma.callFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.callFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callPayload>
          }
          findMany: {
            args: Prisma.callFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callPayload>[]
          }
          create: {
            args: Prisma.callCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callPayload>
          }
          createMany: {
            args: Prisma.callCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.callDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callPayload>
          }
          update: {
            args: Prisma.callUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callPayload>
          }
          deleteMany: {
            args: Prisma.callDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.callUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.callUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callPayload>
          }
          aggregate: {
            args: Prisma.CallAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCall>
          }
          groupBy: {
            args: Prisma.callGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CallGroupByOutputType>[]
          }
          count: {
            args: Prisma.callCountArgs<ExtArgs>,
            result: $Utils.Optional<CallCountAggregateOutputType> | number
          }
        }
      }
      callcenteragent: {
        payload: Prisma.$callcenteragentPayload<ExtArgs>
        fields: Prisma.callcenteragentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.callcenteragentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callcenteragentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.callcenteragentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callcenteragentPayload>
          }
          findFirst: {
            args: Prisma.callcenteragentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callcenteragentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.callcenteragentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callcenteragentPayload>
          }
          findMany: {
            args: Prisma.callcenteragentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callcenteragentPayload>[]
          }
          create: {
            args: Prisma.callcenteragentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callcenteragentPayload>
          }
          createMany: {
            args: Prisma.callcenteragentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.callcenteragentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callcenteragentPayload>
          }
          update: {
            args: Prisma.callcenteragentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callcenteragentPayload>
          }
          deleteMany: {
            args: Prisma.callcenteragentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.callcenteragentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.callcenteragentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$callcenteragentPayload>
          }
          aggregate: {
            args: Prisma.CallcenteragentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCallcenteragent>
          }
          groupBy: {
            args: Prisma.callcenteragentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CallcenteragentGroupByOutputType>[]
          }
          count: {
            args: Prisma.callcenteragentCountArgs<ExtArgs>,
            result: $Utils.Optional<CallcenteragentCountAggregateOutputType> | number
          }
        }
      }
      car: {
        payload: Prisma.$carPayload<ExtArgs>
        fields: Prisma.carFieldRefs
        operations: {
          findUnique: {
            args: Prisma.carFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$carPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.carFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$carPayload>
          }
          findFirst: {
            args: Prisma.carFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$carPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.carFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$carPayload>
          }
          findMany: {
            args: Prisma.carFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$carPayload>[]
          }
          create: {
            args: Prisma.carCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$carPayload>
          }
          createMany: {
            args: Prisma.carCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.carDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$carPayload>
          }
          update: {
            args: Prisma.carUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$carPayload>
          }
          deleteMany: {
            args: Prisma.carDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.carUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.carUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$carPayload>
          }
          aggregate: {
            args: Prisma.CarAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCar>
          }
          groupBy: {
            args: Prisma.carGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CarGroupByOutputType>[]
          }
          count: {
            args: Prisma.carCountArgs<ExtArgs>,
            result: $Utils.Optional<CarCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      driver: {
        payload: Prisma.$driverPayload<ExtArgs>
        fields: Prisma.driverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.driverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$driverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.driverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$driverPayload>
          }
          findFirst: {
            args: Prisma.driverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$driverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.driverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$driverPayload>
          }
          findMany: {
            args: Prisma.driverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$driverPayload>[]
          }
          create: {
            args: Prisma.driverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$driverPayload>
          }
          createMany: {
            args: Prisma.driverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.driverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$driverPayload>
          }
          update: {
            args: Prisma.driverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$driverPayload>
          }
          deleteMany: {
            args: Prisma.driverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.driverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.driverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$driverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.driverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.driverCountArgs<ExtArgs>,
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      drivershift: {
        payload: Prisma.$drivershiftPayload<ExtArgs>
        fields: Prisma.drivershiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.drivershiftFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$drivershiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.drivershiftFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$drivershiftPayload>
          }
          findFirst: {
            args: Prisma.drivershiftFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$drivershiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.drivershiftFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$drivershiftPayload>
          }
          findMany: {
            args: Prisma.drivershiftFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$drivershiftPayload>[]
          }
          create: {
            args: Prisma.drivershiftCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$drivershiftPayload>
          }
          createMany: {
            args: Prisma.drivershiftCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.drivershiftDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$drivershiftPayload>
          }
          update: {
            args: Prisma.drivershiftUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$drivershiftPayload>
          }
          deleteMany: {
            args: Prisma.drivershiftDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.drivershiftUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.drivershiftUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$drivershiftPayload>
          }
          aggregate: {
            args: Prisma.DrivershiftAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDrivershift>
          }
          groupBy: {
            args: Prisma.drivershiftGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DrivershiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.drivershiftCountArgs<ExtArgs>,
            result: $Utils.Optional<DrivershiftCountAggregateOutputType> | number
          }
        }
      }
      message: {
        payload: Prisma.$messagePayload<ExtArgs>
        fields: Prisma.messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findFirst: {
            args: Prisma.messageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findMany: {
            args: Prisma.messageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          create: {
            args: Prisma.messageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          createMany: {
            args: Prisma.messageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.messageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          update: {
            args: Prisma.messageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          deleteMany: {
            args: Prisma.messageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.messageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.messageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.messageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.messageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      rating: {
        payload: Prisma.$ratingPayload<ExtArgs>
        fields: Prisma.ratingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ratingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ratingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ratingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          findFirst: {
            args: Prisma.ratingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ratingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ratingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          findMany: {
            args: Prisma.ratingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>[]
          }
          create: {
            args: Prisma.ratingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          createMany: {
            args: Prisma.ratingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ratingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          update: {
            args: Prisma.ratingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          deleteMany: {
            args: Prisma.ratingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ratingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ratingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.ratingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ratingCountArgs<ExtArgs>,
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      ride: {
        payload: Prisma.$ridePayload<ExtArgs>
        fields: Prisma.rideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rideFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rideFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridePayload>
          }
          findFirst: {
            args: Prisma.rideFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rideFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridePayload>
          }
          findMany: {
            args: Prisma.rideFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridePayload>[]
          }
          create: {
            args: Prisma.rideCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridePayload>
          }
          createMany: {
            args: Prisma.rideCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rideDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridePayload>
          }
          update: {
            args: Prisma.rideUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridePayload>
          }
          deleteMany: {
            args: Prisma.rideDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rideUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rideUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridePayload>
          }
          aggregate: {
            args: Prisma.RideAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRide>
          }
          groupBy: {
            args: Prisma.rideGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RideGroupByOutputType>[]
          }
          count: {
            args: Prisma.rideCountArgs<ExtArgs>,
            result: $Utils.Optional<RideCountAggregateOutputType> | number
          }
        }
      }
      ridestatus: {
        payload: Prisma.$ridestatusPayload<ExtArgs>
        fields: Prisma.ridestatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ridestatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridestatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ridestatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridestatusPayload>
          }
          findFirst: {
            args: Prisma.ridestatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridestatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ridestatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridestatusPayload>
          }
          findMany: {
            args: Prisma.ridestatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridestatusPayload>[]
          }
          create: {
            args: Prisma.ridestatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridestatusPayload>
          }
          createMany: {
            args: Prisma.ridestatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ridestatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridestatusPayload>
          }
          update: {
            args: Prisma.ridestatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridestatusPayload>
          }
          deleteMany: {
            args: Prisma.ridestatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ridestatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ridestatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ridestatusPayload>
          }
          aggregate: {
            args: Prisma.RidestatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRidestatus>
          }
          groupBy: {
            args: Prisma.ridestatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RidestatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ridestatusCountArgs<ExtArgs>,
            result: $Utils.Optional<RidestatusCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CarCountOutputType
   */

  export type CarCountOutputType = {
    drivershift: number
  }

  export type CarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drivershift?: boolean | CarCountOutputTypeCountDrivershiftArgs
  }

  // Custom InputTypes

  /**
   * CarCountOutputType without action
   */
  export type CarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarCountOutputType
     */
    select?: CarCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CarCountOutputType without action
   */
  export type CarCountOutputTypeCountDrivershiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: drivershiftWhereInput
  }



  /**
   * Count Type DrivershiftCountOutputType
   */

  export type DrivershiftCountOutputType = {
    ridestatus: number
  }

  export type DrivershiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ridestatus?: boolean | DrivershiftCountOutputTypeCountRidestatusArgs
  }

  // Custom InputTypes

  /**
   * DrivershiftCountOutputType without action
   */
  export type DrivershiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrivershiftCountOutputType
     */
    select?: DrivershiftCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DrivershiftCountOutputType without action
   */
  export type DrivershiftCountOutputTypeCountRidestatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ridestatusWhereInput
  }



  /**
   * Count Type RideCountOutputType
   */

  export type RideCountOutputType = {
    message: number
    rating: number
    ridestatus: number
  }

  export type RideCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | RideCountOutputTypeCountMessageArgs
    rating?: boolean | RideCountOutputTypeCountRatingArgs
    ridestatus?: boolean | RideCountOutputTypeCountRidestatusArgs
  }

  // Custom InputTypes

  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideCountOutputType
     */
    select?: RideCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }


  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingWhereInput
  }


  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountRidestatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ridestatusWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    call_call_userCallIdTouser: number
    call_call_userAnswerIdTouser: number
    callcenteragent: number
    customer: number
    driver: number
    drivershift: number
    message_message_senderIdTouser: number
    message_message_receiverIdTouser: number
    rating_rating_driverIdTouser: number
    rating_rating_userIdTouser: number
    ridestatus: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    call_call_userCallIdTouser?: boolean | UserCountOutputTypeCountCall_call_userCallIdTouserArgs
    call_call_userAnswerIdTouser?: boolean | UserCountOutputTypeCountCall_call_userAnswerIdTouserArgs
    callcenteragent?: boolean | UserCountOutputTypeCountCallcenteragentArgs
    customer?: boolean | UserCountOutputTypeCountCustomerArgs
    driver?: boolean | UserCountOutputTypeCountDriverArgs
    drivershift?: boolean | UserCountOutputTypeCountDrivershiftArgs
    message_message_senderIdTouser?: boolean | UserCountOutputTypeCountMessage_message_senderIdTouserArgs
    message_message_receiverIdTouser?: boolean | UserCountOutputTypeCountMessage_message_receiverIdTouserArgs
    rating_rating_driverIdTouser?: boolean | UserCountOutputTypeCountRating_rating_driverIdTouserArgs
    rating_rating_userIdTouser?: boolean | UserCountOutputTypeCountRating_rating_userIdTouserArgs
    ridestatus?: boolean | UserCountOutputTypeCountRidestatusArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCall_call_userCallIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: callWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCall_call_userAnswerIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: callWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCallcenteragentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: callcenteragentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: driverWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDrivershiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: drivershiftWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_message_senderIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_message_receiverIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRating_rating_driverIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRating_rating_userIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRidestatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ridestatusWhereInput
  }



  /**
   * Models
   */

  /**
   * Model call
   */

  export type AggregateCall = {
    _count: CallCountAggregateOutputType | null
    _min: CallMinAggregateOutputType | null
    _max: CallMaxAggregateOutputType | null
  }

  export type CallMinAggregateOutputType = {
    uuid: string | null
    userCallId: string | null
    userAnswerId: string | null
    beginCallingTime: Date | null
    endCallingTime: Date | null
    callingStatus: string | null
  }

  export type CallMaxAggregateOutputType = {
    uuid: string | null
    userCallId: string | null
    userAnswerId: string | null
    beginCallingTime: Date | null
    endCallingTime: Date | null
    callingStatus: string | null
  }

  export type CallCountAggregateOutputType = {
    uuid: number
    userCallId: number
    userAnswerId: number
    beginCallingTime: number
    endCallingTime: number
    callingStatus: number
    _all: number
  }


  export type CallMinAggregateInputType = {
    uuid?: true
    userCallId?: true
    userAnswerId?: true
    beginCallingTime?: true
    endCallingTime?: true
    callingStatus?: true
  }

  export type CallMaxAggregateInputType = {
    uuid?: true
    userCallId?: true
    userAnswerId?: true
    beginCallingTime?: true
    endCallingTime?: true
    callingStatus?: true
  }

  export type CallCountAggregateInputType = {
    uuid?: true
    userCallId?: true
    userAnswerId?: true
    beginCallingTime?: true
    endCallingTime?: true
    callingStatus?: true
    _all?: true
  }

  export type CallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which call to aggregate.
     */
    where?: callWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calls to fetch.
     */
    orderBy?: callOrderByWithRelationInput | callOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: callWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned calls
    **/
    _count?: true | CallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallMaxAggregateInputType
  }

  export type GetCallAggregateType<T extends CallAggregateArgs> = {
        [P in keyof T & keyof AggregateCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCall[P]>
      : GetScalarType<T[P], AggregateCall[P]>
  }




  export type callGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: callWhereInput
    orderBy?: callOrderByWithAggregationInput | callOrderByWithAggregationInput[]
    by: CallScalarFieldEnum[] | CallScalarFieldEnum
    having?: callScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallCountAggregateInputType | true
    _min?: CallMinAggregateInputType
    _max?: CallMaxAggregateInputType
  }

  export type CallGroupByOutputType = {
    uuid: string
    userCallId: string
    userAnswerId: string
    beginCallingTime: Date
    endCallingTime: Date | null
    callingStatus: string
    _count: CallCountAggregateOutputType | null
    _min: CallMinAggregateOutputType | null
    _max: CallMaxAggregateOutputType | null
  }

  type GetCallGroupByPayload<T extends callGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallGroupByOutputType[P]>
            : GetScalarType<T[P], CallGroupByOutputType[P]>
        }
      >
    >


  export type callSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    userCallId?: boolean
    userAnswerId?: boolean
    beginCallingTime?: boolean
    endCallingTime?: boolean
    callingStatus?: boolean
    user_call_userCallIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_call_userAnswerIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["call"]>

  export type callSelectScalar = {
    uuid?: boolean
    userCallId?: boolean
    userAnswerId?: boolean
    beginCallingTime?: boolean
    endCallingTime?: boolean
    callingStatus?: boolean
  }

  export type callInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_call_userCallIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_call_userAnswerIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }


  export type $callPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "call"
    objects: {
      user_call_userCallIdTouser: Prisma.$userPayload<ExtArgs>
      user_call_userAnswerIdTouser: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      userCallId: string
      userAnswerId: string
      beginCallingTime: Date
      endCallingTime: Date | null
      callingStatus: string
    }, ExtArgs["result"]["call"]>
    composites: {}
  }


  type callGetPayload<S extends boolean | null | undefined | callDefaultArgs> = $Result.GetResult<Prisma.$callPayload, S>

  type callCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<callFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CallCountAggregateInputType | true
    }

  export interface callDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['call'], meta: { name: 'call' } }
    /**
     * Find zero or one Call that matches the filter.
     * @param {callFindUniqueArgs} args - Arguments to find a Call
     * @example
     * // Get one Call
     * const call = await prisma.call.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends callFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, callFindUniqueArgs<ExtArgs>>
    ): Prisma__callClient<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Call that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {callFindUniqueOrThrowArgs} args - Arguments to find a Call
     * @example
     * // Get one Call
     * const call = await prisma.call.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends callFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, callFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__callClient<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Call that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callFindFirstArgs} args - Arguments to find a Call
     * @example
     * // Get one Call
     * const call = await prisma.call.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends callFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, callFindFirstArgs<ExtArgs>>
    ): Prisma__callClient<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Call that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callFindFirstOrThrowArgs} args - Arguments to find a Call
     * @example
     * // Get one Call
     * const call = await prisma.call.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends callFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, callFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__callClient<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calls
     * const calls = await prisma.call.findMany()
     * 
     * // Get first 10 Calls
     * const calls = await prisma.call.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const callWithUuidOnly = await prisma.call.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends callFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, callFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Call.
     * @param {callCreateArgs} args - Arguments to create a Call.
     * @example
     * // Create one Call
     * const Call = await prisma.call.create({
     *   data: {
     *     // ... data to create a Call
     *   }
     * })
     * 
    **/
    create<T extends callCreateArgs<ExtArgs>>(
      args: SelectSubset<T, callCreateArgs<ExtArgs>>
    ): Prisma__callClient<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Calls.
     *     @param {callCreateManyArgs} args - Arguments to create many Calls.
     *     @example
     *     // Create many Calls
     *     const call = await prisma.call.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends callCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, callCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Call.
     * @param {callDeleteArgs} args - Arguments to delete one Call.
     * @example
     * // Delete one Call
     * const Call = await prisma.call.delete({
     *   where: {
     *     // ... filter to delete one Call
     *   }
     * })
     * 
    **/
    delete<T extends callDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, callDeleteArgs<ExtArgs>>
    ): Prisma__callClient<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Call.
     * @param {callUpdateArgs} args - Arguments to update one Call.
     * @example
     * // Update one Call
     * const call = await prisma.call.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends callUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, callUpdateArgs<ExtArgs>>
    ): Prisma__callClient<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Calls.
     * @param {callDeleteManyArgs} args - Arguments to filter Calls to delete.
     * @example
     * // Delete a few Calls
     * const { count } = await prisma.call.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends callDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, callDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calls
     * const call = await prisma.call.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends callUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, callUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Call.
     * @param {callUpsertArgs} args - Arguments to update or create a Call.
     * @example
     * // Update or create a Call
     * const call = await prisma.call.upsert({
     *   create: {
     *     // ... data to create a Call
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Call we want to update
     *   }
     * })
    **/
    upsert<T extends callUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, callUpsertArgs<ExtArgs>>
    ): Prisma__callClient<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callCountArgs} args - Arguments to filter Calls to count.
     * @example
     * // Count the number of Calls
     * const count = await prisma.call.count({
     *   where: {
     *     // ... the filter for the Calls we want to count
     *   }
     * })
    **/
    count<T extends callCountArgs>(
      args?: Subset<T, callCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Call.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallAggregateArgs>(args: Subset<T, CallAggregateArgs>): Prisma.PrismaPromise<GetCallAggregateType<T>>

    /**
     * Group by Call.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends callGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: callGroupByArgs['orderBy'] }
        : { orderBy?: callGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, callGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the call model
   */
  readonly fields: callFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for call.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__callClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user_call_userCallIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user_call_userAnswerIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the call model
   */ 
  interface callFieldRefs {
    readonly uuid: FieldRef<"call", 'String'>
    readonly userCallId: FieldRef<"call", 'String'>
    readonly userAnswerId: FieldRef<"call", 'String'>
    readonly beginCallingTime: FieldRef<"call", 'DateTime'>
    readonly endCallingTime: FieldRef<"call", 'DateTime'>
    readonly callingStatus: FieldRef<"call", 'String'>
  }
    

  // Custom InputTypes

  /**
   * call findUnique
   */
  export type callFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    /**
     * Filter, which call to fetch.
     */
    where: callWhereUniqueInput
  }


  /**
   * call findUniqueOrThrow
   */
  export type callFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    /**
     * Filter, which call to fetch.
     */
    where: callWhereUniqueInput
  }


  /**
   * call findFirst
   */
  export type callFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    /**
     * Filter, which call to fetch.
     */
    where?: callWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calls to fetch.
     */
    orderBy?: callOrderByWithRelationInput | callOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calls.
     */
    cursor?: callWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calls.
     */
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }


  /**
   * call findFirstOrThrow
   */
  export type callFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    /**
     * Filter, which call to fetch.
     */
    where?: callWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calls to fetch.
     */
    orderBy?: callOrderByWithRelationInput | callOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calls.
     */
    cursor?: callWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calls.
     */
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }


  /**
   * call findMany
   */
  export type callFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    /**
     * Filter, which calls to fetch.
     */
    where?: callWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calls to fetch.
     */
    orderBy?: callOrderByWithRelationInput | callOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing calls.
     */
    cursor?: callWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calls.
     */
    skip?: number
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }


  /**
   * call create
   */
  export type callCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    /**
     * The data needed to create a call.
     */
    data: XOR<callCreateInput, callUncheckedCreateInput>
  }


  /**
   * call createMany
   */
  export type callCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many calls.
     */
    data: callCreateManyInput | callCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * call update
   */
  export type callUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    /**
     * The data needed to update a call.
     */
    data: XOR<callUpdateInput, callUncheckedUpdateInput>
    /**
     * Choose, which call to update.
     */
    where: callWhereUniqueInput
  }


  /**
   * call updateMany
   */
  export type callUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update calls.
     */
    data: XOR<callUpdateManyMutationInput, callUncheckedUpdateManyInput>
    /**
     * Filter which calls to update
     */
    where?: callWhereInput
  }


  /**
   * call upsert
   */
  export type callUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    /**
     * The filter to search for the call to update in case it exists.
     */
    where: callWhereUniqueInput
    /**
     * In case the call found by the `where` argument doesn't exist, create a new call with this data.
     */
    create: XOR<callCreateInput, callUncheckedCreateInput>
    /**
     * In case the call was found with the provided `where` argument, update it with this data.
     */
    update: XOR<callUpdateInput, callUncheckedUpdateInput>
  }


  /**
   * call delete
   */
  export type callDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    /**
     * Filter which call to delete.
     */
    where: callWhereUniqueInput
  }


  /**
   * call deleteMany
   */
  export type callDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which calls to delete
     */
    where?: callWhereInput
  }


  /**
   * call without action
   */
  export type callDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
  }



  /**
   * Model callcenteragent
   */

  export type AggregateCallcenteragent = {
    _count: CallcenteragentCountAggregateOutputType | null
    _min: CallcenteragentMinAggregateOutputType | null
    _max: CallcenteragentMaxAggregateOutputType | null
  }

  export type CallcenteragentMinAggregateOutputType = {
    uuid: string | null
    userId: string | null
    state: string | null
  }

  export type CallcenteragentMaxAggregateOutputType = {
    uuid: string | null
    userId: string | null
    state: string | null
  }

  export type CallcenteragentCountAggregateOutputType = {
    uuid: number
    userId: number
    state: number
    _all: number
  }


  export type CallcenteragentMinAggregateInputType = {
    uuid?: true
    userId?: true
    state?: true
  }

  export type CallcenteragentMaxAggregateInputType = {
    uuid?: true
    userId?: true
    state?: true
  }

  export type CallcenteragentCountAggregateInputType = {
    uuid?: true
    userId?: true
    state?: true
    _all?: true
  }

  export type CallcenteragentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which callcenteragent to aggregate.
     */
    where?: callcenteragentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of callcenteragents to fetch.
     */
    orderBy?: callcenteragentOrderByWithRelationInput | callcenteragentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: callcenteragentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` callcenteragents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` callcenteragents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned callcenteragents
    **/
    _count?: true | CallcenteragentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallcenteragentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallcenteragentMaxAggregateInputType
  }

  export type GetCallcenteragentAggregateType<T extends CallcenteragentAggregateArgs> = {
        [P in keyof T & keyof AggregateCallcenteragent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallcenteragent[P]>
      : GetScalarType<T[P], AggregateCallcenteragent[P]>
  }




  export type callcenteragentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: callcenteragentWhereInput
    orderBy?: callcenteragentOrderByWithAggregationInput | callcenteragentOrderByWithAggregationInput[]
    by: CallcenteragentScalarFieldEnum[] | CallcenteragentScalarFieldEnum
    having?: callcenteragentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallcenteragentCountAggregateInputType | true
    _min?: CallcenteragentMinAggregateInputType
    _max?: CallcenteragentMaxAggregateInputType
  }

  export type CallcenteragentGroupByOutputType = {
    uuid: string
    userId: string
    state: string
    _count: CallcenteragentCountAggregateOutputType | null
    _min: CallcenteragentMinAggregateOutputType | null
    _max: CallcenteragentMaxAggregateOutputType | null
  }

  type GetCallcenteragentGroupByPayload<T extends callcenteragentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallcenteragentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallcenteragentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallcenteragentGroupByOutputType[P]>
            : GetScalarType<T[P], CallcenteragentGroupByOutputType[P]>
        }
      >
    >


  export type callcenteragentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    userId?: boolean
    state?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callcenteragent"]>

  export type callcenteragentSelectScalar = {
    uuid?: boolean
    userId?: boolean
    state?: boolean
  }

  export type callcenteragentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }


  export type $callcenteragentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "callcenteragent"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      userId: string
      state: string
    }, ExtArgs["result"]["callcenteragent"]>
    composites: {}
  }


  type callcenteragentGetPayload<S extends boolean | null | undefined | callcenteragentDefaultArgs> = $Result.GetResult<Prisma.$callcenteragentPayload, S>

  type callcenteragentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<callcenteragentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CallcenteragentCountAggregateInputType | true
    }

  export interface callcenteragentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['callcenteragent'], meta: { name: 'callcenteragent' } }
    /**
     * Find zero or one Callcenteragent that matches the filter.
     * @param {callcenteragentFindUniqueArgs} args - Arguments to find a Callcenteragent
     * @example
     * // Get one Callcenteragent
     * const callcenteragent = await prisma.callcenteragent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends callcenteragentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, callcenteragentFindUniqueArgs<ExtArgs>>
    ): Prisma__callcenteragentClient<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Callcenteragent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {callcenteragentFindUniqueOrThrowArgs} args - Arguments to find a Callcenteragent
     * @example
     * // Get one Callcenteragent
     * const callcenteragent = await prisma.callcenteragent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends callcenteragentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, callcenteragentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__callcenteragentClient<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Callcenteragent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callcenteragentFindFirstArgs} args - Arguments to find a Callcenteragent
     * @example
     * // Get one Callcenteragent
     * const callcenteragent = await prisma.callcenteragent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends callcenteragentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, callcenteragentFindFirstArgs<ExtArgs>>
    ): Prisma__callcenteragentClient<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Callcenteragent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callcenteragentFindFirstOrThrowArgs} args - Arguments to find a Callcenteragent
     * @example
     * // Get one Callcenteragent
     * const callcenteragent = await prisma.callcenteragent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends callcenteragentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, callcenteragentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__callcenteragentClient<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Callcenteragents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callcenteragentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Callcenteragents
     * const callcenteragents = await prisma.callcenteragent.findMany()
     * 
     * // Get first 10 Callcenteragents
     * const callcenteragents = await prisma.callcenteragent.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const callcenteragentWithUuidOnly = await prisma.callcenteragent.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends callcenteragentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, callcenteragentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Callcenteragent.
     * @param {callcenteragentCreateArgs} args - Arguments to create a Callcenteragent.
     * @example
     * // Create one Callcenteragent
     * const Callcenteragent = await prisma.callcenteragent.create({
     *   data: {
     *     // ... data to create a Callcenteragent
     *   }
     * })
     * 
    **/
    create<T extends callcenteragentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, callcenteragentCreateArgs<ExtArgs>>
    ): Prisma__callcenteragentClient<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Callcenteragents.
     *     @param {callcenteragentCreateManyArgs} args - Arguments to create many Callcenteragents.
     *     @example
     *     // Create many Callcenteragents
     *     const callcenteragent = await prisma.callcenteragent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends callcenteragentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, callcenteragentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Callcenteragent.
     * @param {callcenteragentDeleteArgs} args - Arguments to delete one Callcenteragent.
     * @example
     * // Delete one Callcenteragent
     * const Callcenteragent = await prisma.callcenteragent.delete({
     *   where: {
     *     // ... filter to delete one Callcenteragent
     *   }
     * })
     * 
    **/
    delete<T extends callcenteragentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, callcenteragentDeleteArgs<ExtArgs>>
    ): Prisma__callcenteragentClient<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Callcenteragent.
     * @param {callcenteragentUpdateArgs} args - Arguments to update one Callcenteragent.
     * @example
     * // Update one Callcenteragent
     * const callcenteragent = await prisma.callcenteragent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends callcenteragentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, callcenteragentUpdateArgs<ExtArgs>>
    ): Prisma__callcenteragentClient<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Callcenteragents.
     * @param {callcenteragentDeleteManyArgs} args - Arguments to filter Callcenteragents to delete.
     * @example
     * // Delete a few Callcenteragents
     * const { count } = await prisma.callcenteragent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends callcenteragentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, callcenteragentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Callcenteragents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callcenteragentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Callcenteragents
     * const callcenteragent = await prisma.callcenteragent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends callcenteragentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, callcenteragentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Callcenteragent.
     * @param {callcenteragentUpsertArgs} args - Arguments to update or create a Callcenteragent.
     * @example
     * // Update or create a Callcenteragent
     * const callcenteragent = await prisma.callcenteragent.upsert({
     *   create: {
     *     // ... data to create a Callcenteragent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Callcenteragent we want to update
     *   }
     * })
    **/
    upsert<T extends callcenteragentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, callcenteragentUpsertArgs<ExtArgs>>
    ): Prisma__callcenteragentClient<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Callcenteragents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callcenteragentCountArgs} args - Arguments to filter Callcenteragents to count.
     * @example
     * // Count the number of Callcenteragents
     * const count = await prisma.callcenteragent.count({
     *   where: {
     *     // ... the filter for the Callcenteragents we want to count
     *   }
     * })
    **/
    count<T extends callcenteragentCountArgs>(
      args?: Subset<T, callcenteragentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallcenteragentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Callcenteragent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallcenteragentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallcenteragentAggregateArgs>(args: Subset<T, CallcenteragentAggregateArgs>): Prisma.PrismaPromise<GetCallcenteragentAggregateType<T>>

    /**
     * Group by Callcenteragent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callcenteragentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends callcenteragentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: callcenteragentGroupByArgs['orderBy'] }
        : { orderBy?: callcenteragentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, callcenteragentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallcenteragentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the callcenteragent model
   */
  readonly fields: callcenteragentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for callcenteragent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__callcenteragentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the callcenteragent model
   */ 
  interface callcenteragentFieldRefs {
    readonly uuid: FieldRef<"callcenteragent", 'String'>
    readonly userId: FieldRef<"callcenteragent", 'String'>
    readonly state: FieldRef<"callcenteragent", 'String'>
  }
    

  // Custom InputTypes

  /**
   * callcenteragent findUnique
   */
  export type callcenteragentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    /**
     * Filter, which callcenteragent to fetch.
     */
    where: callcenteragentWhereUniqueInput
  }


  /**
   * callcenteragent findUniqueOrThrow
   */
  export type callcenteragentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    /**
     * Filter, which callcenteragent to fetch.
     */
    where: callcenteragentWhereUniqueInput
  }


  /**
   * callcenteragent findFirst
   */
  export type callcenteragentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    /**
     * Filter, which callcenteragent to fetch.
     */
    where?: callcenteragentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of callcenteragents to fetch.
     */
    orderBy?: callcenteragentOrderByWithRelationInput | callcenteragentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for callcenteragents.
     */
    cursor?: callcenteragentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` callcenteragents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` callcenteragents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of callcenteragents.
     */
    distinct?: CallcenteragentScalarFieldEnum | CallcenteragentScalarFieldEnum[]
  }


  /**
   * callcenteragent findFirstOrThrow
   */
  export type callcenteragentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    /**
     * Filter, which callcenteragent to fetch.
     */
    where?: callcenteragentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of callcenteragents to fetch.
     */
    orderBy?: callcenteragentOrderByWithRelationInput | callcenteragentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for callcenteragents.
     */
    cursor?: callcenteragentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` callcenteragents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` callcenteragents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of callcenteragents.
     */
    distinct?: CallcenteragentScalarFieldEnum | CallcenteragentScalarFieldEnum[]
  }


  /**
   * callcenteragent findMany
   */
  export type callcenteragentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    /**
     * Filter, which callcenteragents to fetch.
     */
    where?: callcenteragentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of callcenteragents to fetch.
     */
    orderBy?: callcenteragentOrderByWithRelationInput | callcenteragentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing callcenteragents.
     */
    cursor?: callcenteragentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` callcenteragents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` callcenteragents.
     */
    skip?: number
    distinct?: CallcenteragentScalarFieldEnum | CallcenteragentScalarFieldEnum[]
  }


  /**
   * callcenteragent create
   */
  export type callcenteragentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    /**
     * The data needed to create a callcenteragent.
     */
    data: XOR<callcenteragentCreateInput, callcenteragentUncheckedCreateInput>
  }


  /**
   * callcenteragent createMany
   */
  export type callcenteragentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many callcenteragents.
     */
    data: callcenteragentCreateManyInput | callcenteragentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * callcenteragent update
   */
  export type callcenteragentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    /**
     * The data needed to update a callcenteragent.
     */
    data: XOR<callcenteragentUpdateInput, callcenteragentUncheckedUpdateInput>
    /**
     * Choose, which callcenteragent to update.
     */
    where: callcenteragentWhereUniqueInput
  }


  /**
   * callcenteragent updateMany
   */
  export type callcenteragentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update callcenteragents.
     */
    data: XOR<callcenteragentUpdateManyMutationInput, callcenteragentUncheckedUpdateManyInput>
    /**
     * Filter which callcenteragents to update
     */
    where?: callcenteragentWhereInput
  }


  /**
   * callcenteragent upsert
   */
  export type callcenteragentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    /**
     * The filter to search for the callcenteragent to update in case it exists.
     */
    where: callcenteragentWhereUniqueInput
    /**
     * In case the callcenteragent found by the `where` argument doesn't exist, create a new callcenteragent with this data.
     */
    create: XOR<callcenteragentCreateInput, callcenteragentUncheckedCreateInput>
    /**
     * In case the callcenteragent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<callcenteragentUpdateInput, callcenteragentUncheckedUpdateInput>
  }


  /**
   * callcenteragent delete
   */
  export type callcenteragentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    /**
     * Filter which callcenteragent to delete.
     */
    where: callcenteragentWhereUniqueInput
  }


  /**
   * callcenteragent deleteMany
   */
  export type callcenteragentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which callcenteragents to delete
     */
    where?: callcenteragentWhereInput
  }


  /**
   * callcenteragent without action
   */
  export type callcenteragentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
  }



  /**
   * Model car
   */

  export type AggregateCar = {
    _count: CarCountAggregateOutputType | null
    _avg: CarAvgAggregateOutputType | null
    _sum: CarSumAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  export type CarAvgAggregateOutputType = {
    seat: number | null
  }

  export type CarSumAggregateOutputType = {
    seat: number | null
  }

  export type CarMinAggregateOutputType = {
    uuid: string | null
    modelName: string | null
    modelDescription: string | null
    manufactureYear: Date | null
    seat: number | null
    color: string | null
    carImage: string | null
    licensePlate: string | null
  }

  export type CarMaxAggregateOutputType = {
    uuid: string | null
    modelName: string | null
    modelDescription: string | null
    manufactureYear: Date | null
    seat: number | null
    color: string | null
    carImage: string | null
    licensePlate: string | null
  }

  export type CarCountAggregateOutputType = {
    uuid: number
    modelName: number
    modelDescription: number
    manufactureYear: number
    seat: number
    color: number
    carImage: number
    licensePlate: number
    _all: number
  }


  export type CarAvgAggregateInputType = {
    seat?: true
  }

  export type CarSumAggregateInputType = {
    seat?: true
  }

  export type CarMinAggregateInputType = {
    uuid?: true
    modelName?: true
    modelDescription?: true
    manufactureYear?: true
    seat?: true
    color?: true
    carImage?: true
    licensePlate?: true
  }

  export type CarMaxAggregateInputType = {
    uuid?: true
    modelName?: true
    modelDescription?: true
    manufactureYear?: true
    seat?: true
    color?: true
    carImage?: true
    licensePlate?: true
  }

  export type CarCountAggregateInputType = {
    uuid?: true
    modelName?: true
    modelDescription?: true
    manufactureYear?: true
    seat?: true
    color?: true
    carImage?: true
    licensePlate?: true
    _all?: true
  }

  export type CarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which car to aggregate.
     */
    where?: carWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cars to fetch.
     */
    orderBy?: carOrderByWithRelationInput | carOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: carWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cars
    **/
    _count?: true | CarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarMaxAggregateInputType
  }

  export type GetCarAggregateType<T extends CarAggregateArgs> = {
        [P in keyof T & keyof AggregateCar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCar[P]>
      : GetScalarType<T[P], AggregateCar[P]>
  }




  export type carGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: carWhereInput
    orderBy?: carOrderByWithAggregationInput | carOrderByWithAggregationInput[]
    by: CarScalarFieldEnum[] | CarScalarFieldEnum
    having?: carScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarCountAggregateInputType | true
    _avg?: CarAvgAggregateInputType
    _sum?: CarSumAggregateInputType
    _min?: CarMinAggregateInputType
    _max?: CarMaxAggregateInputType
  }

  export type CarGroupByOutputType = {
    uuid: string
    modelName: string
    modelDescription: string | null
    manufactureYear: Date
    seat: number
    color: string | null
    carImage: string
    licensePlate: string
    _count: CarCountAggregateOutputType | null
    _avg: CarAvgAggregateOutputType | null
    _sum: CarSumAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  type GetCarGroupByPayload<T extends carGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarGroupByOutputType[P]>
            : GetScalarType<T[P], CarGroupByOutputType[P]>
        }
      >
    >


  export type carSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    modelName?: boolean
    modelDescription?: boolean
    manufactureYear?: boolean
    seat?: boolean
    color?: boolean
    carImage?: boolean
    licensePlate?: boolean
    drivershift?: boolean | car$drivershiftArgs<ExtArgs>
    _count?: boolean | CarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["car"]>

  export type carSelectScalar = {
    uuid?: boolean
    modelName?: boolean
    modelDescription?: boolean
    manufactureYear?: boolean
    seat?: boolean
    color?: boolean
    carImage?: boolean
    licensePlate?: boolean
  }

  export type carInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drivershift?: boolean | car$drivershiftArgs<ExtArgs>
    _count?: boolean | CarCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $carPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "car"
    objects: {
      drivershift: Prisma.$drivershiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      modelName: string
      modelDescription: string | null
      manufactureYear: Date
      seat: number
      color: string | null
      carImage: string
      licensePlate: string
    }, ExtArgs["result"]["car"]>
    composites: {}
  }


  type carGetPayload<S extends boolean | null | undefined | carDefaultArgs> = $Result.GetResult<Prisma.$carPayload, S>

  type carCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<carFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CarCountAggregateInputType | true
    }

  export interface carDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['car'], meta: { name: 'car' } }
    /**
     * Find zero or one Car that matches the filter.
     * @param {carFindUniqueArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends carFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, carFindUniqueArgs<ExtArgs>>
    ): Prisma__carClient<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Car that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {carFindUniqueOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends carFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, carFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__carClient<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Car that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carFindFirstArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends carFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, carFindFirstArgs<ExtArgs>>
    ): Prisma__carClient<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Car that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carFindFirstOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends carFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, carFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__carClient<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cars
     * const cars = await prisma.car.findMany()
     * 
     * // Get first 10 Cars
     * const cars = await prisma.car.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const carWithUuidOnly = await prisma.car.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends carFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, carFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Car.
     * @param {carCreateArgs} args - Arguments to create a Car.
     * @example
     * // Create one Car
     * const Car = await prisma.car.create({
     *   data: {
     *     // ... data to create a Car
     *   }
     * })
     * 
    **/
    create<T extends carCreateArgs<ExtArgs>>(
      args: SelectSubset<T, carCreateArgs<ExtArgs>>
    ): Prisma__carClient<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cars.
     *     @param {carCreateManyArgs} args - Arguments to create many Cars.
     *     @example
     *     // Create many Cars
     *     const car = await prisma.car.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends carCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, carCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Car.
     * @param {carDeleteArgs} args - Arguments to delete one Car.
     * @example
     * // Delete one Car
     * const Car = await prisma.car.delete({
     *   where: {
     *     // ... filter to delete one Car
     *   }
     * })
     * 
    **/
    delete<T extends carDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, carDeleteArgs<ExtArgs>>
    ): Prisma__carClient<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Car.
     * @param {carUpdateArgs} args - Arguments to update one Car.
     * @example
     * // Update one Car
     * const car = await prisma.car.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends carUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, carUpdateArgs<ExtArgs>>
    ): Prisma__carClient<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cars.
     * @param {carDeleteManyArgs} args - Arguments to filter Cars to delete.
     * @example
     * // Delete a few Cars
     * const { count } = await prisma.car.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends carDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, carDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cars
     * const car = await prisma.car.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends carUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, carUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Car.
     * @param {carUpsertArgs} args - Arguments to update or create a Car.
     * @example
     * // Update or create a Car
     * const car = await prisma.car.upsert({
     *   create: {
     *     // ... data to create a Car
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Car we want to update
     *   }
     * })
    **/
    upsert<T extends carUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, carUpsertArgs<ExtArgs>>
    ): Prisma__carClient<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carCountArgs} args - Arguments to filter Cars to count.
     * @example
     * // Count the number of Cars
     * const count = await prisma.car.count({
     *   where: {
     *     // ... the filter for the Cars we want to count
     *   }
     * })
    **/
    count<T extends carCountArgs>(
      args?: Subset<T, carCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarAggregateArgs>(args: Subset<T, CarAggregateArgs>): Prisma.PrismaPromise<GetCarAggregateType<T>>

    /**
     * Group by Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends carGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: carGroupByArgs['orderBy'] }
        : { orderBy?: carGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, carGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the car model
   */
  readonly fields: carFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for car.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__carClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    drivershift<T extends car$drivershiftArgs<ExtArgs> = {}>(args?: Subset<T, car$drivershiftArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the car model
   */ 
  interface carFieldRefs {
    readonly uuid: FieldRef<"car", 'String'>
    readonly modelName: FieldRef<"car", 'String'>
    readonly modelDescription: FieldRef<"car", 'String'>
    readonly manufactureYear: FieldRef<"car", 'DateTime'>
    readonly seat: FieldRef<"car", 'Int'>
    readonly color: FieldRef<"car", 'String'>
    readonly carImage: FieldRef<"car", 'String'>
    readonly licensePlate: FieldRef<"car", 'String'>
  }
    

  // Custom InputTypes

  /**
   * car findUnique
   */
  export type carFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
    /**
     * Filter, which car to fetch.
     */
    where: carWhereUniqueInput
  }


  /**
   * car findUniqueOrThrow
   */
  export type carFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
    /**
     * Filter, which car to fetch.
     */
    where: carWhereUniqueInput
  }


  /**
   * car findFirst
   */
  export type carFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
    /**
     * Filter, which car to fetch.
     */
    where?: carWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cars to fetch.
     */
    orderBy?: carOrderByWithRelationInput | carOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cars.
     */
    cursor?: carWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }


  /**
   * car findFirstOrThrow
   */
  export type carFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
    /**
     * Filter, which car to fetch.
     */
    where?: carWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cars to fetch.
     */
    orderBy?: carOrderByWithRelationInput | carOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cars.
     */
    cursor?: carWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }


  /**
   * car findMany
   */
  export type carFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
    /**
     * Filter, which cars to fetch.
     */
    where?: carWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cars to fetch.
     */
    orderBy?: carOrderByWithRelationInput | carOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cars.
     */
    cursor?: carWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cars.
     */
    skip?: number
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }


  /**
   * car create
   */
  export type carCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
    /**
     * The data needed to create a car.
     */
    data: XOR<carCreateInput, carUncheckedCreateInput>
  }


  /**
   * car createMany
   */
  export type carCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cars.
     */
    data: carCreateManyInput | carCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * car update
   */
  export type carUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
    /**
     * The data needed to update a car.
     */
    data: XOR<carUpdateInput, carUncheckedUpdateInput>
    /**
     * Choose, which car to update.
     */
    where: carWhereUniqueInput
  }


  /**
   * car updateMany
   */
  export type carUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cars.
     */
    data: XOR<carUpdateManyMutationInput, carUncheckedUpdateManyInput>
    /**
     * Filter which cars to update
     */
    where?: carWhereInput
  }


  /**
   * car upsert
   */
  export type carUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
    /**
     * The filter to search for the car to update in case it exists.
     */
    where: carWhereUniqueInput
    /**
     * In case the car found by the `where` argument doesn't exist, create a new car with this data.
     */
    create: XOR<carCreateInput, carUncheckedCreateInput>
    /**
     * In case the car was found with the provided `where` argument, update it with this data.
     */
    update: XOR<carUpdateInput, carUncheckedUpdateInput>
  }


  /**
   * car delete
   */
  export type carDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
    /**
     * Filter which car to delete.
     */
    where: carWhereUniqueInput
  }


  /**
   * car deleteMany
   */
  export type carDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cars to delete
     */
    where?: carWhereInput
  }


  /**
   * car.drivershift
   */
  export type car$drivershiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    where?: drivershiftWhereInput
    orderBy?: drivershiftOrderByWithRelationInput | drivershiftOrderByWithRelationInput[]
    cursor?: drivershiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DrivershiftScalarFieldEnum | DrivershiftScalarFieldEnum[]
  }


  /**
   * car without action
   */
  export type carDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the car
     */
    select?: carSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carInclude<ExtArgs> | null
  }



  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    uuid: string | null
    userId: string | null
    state: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    uuid: string | null
    userId: string | null
    state: string | null
  }

  export type CustomerCountAggregateOutputType = {
    uuid: number
    userId: number
    state: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    uuid?: true
    userId?: true
    state?: true
  }

  export type CustomerMaxAggregateInputType = {
    uuid?: true
    userId?: true
    state?: true
  }

  export type CustomerCountAggregateInputType = {
    uuid?: true
    userId?: true
    state?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    uuid: string
    userId: string | null
    state: string
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    userId?: boolean
    state?: boolean
    user?: boolean | customer$userArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectScalar = {
    uuid?: boolean
    userId?: boolean
    state?: boolean
  }

  export type customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | customer$userArgs<ExtArgs>
  }


  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      userId: string | null
      state: string
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }


  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const customerWithUuidOnly = await prisma.customer.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends customerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends customerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, customerCreateArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Customers.
     *     @param {customerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends customerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends customerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, customerDeleteArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, customerUpdateArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends customerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, customerUpsertArgs<ExtArgs>>
    ): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends customer$userArgs<ExtArgs> = {}>(args?: Subset<T, customer$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the customer model
   */ 
  interface customerFieldRefs {
    readonly uuid: FieldRef<"customer", 'String'>
    readonly userId: FieldRef<"customer", 'String'>
    readonly state: FieldRef<"customer", 'String'>
  }
    

  // Custom InputTypes

  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }


  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }


  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data?: XOR<customerCreateInput, customerUncheckedCreateInput>
  }


  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }


  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
  }


  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }


  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }


  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
  }


  /**
   * customer.user
   */
  export type customer$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
  }



  /**
   * Model driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverMinAggregateOutputType = {
    uuid: string | null
    userId: string | null
    drivingLicenceNumber: string | null
    expiryDate: Date | null
    state: string | null
  }

  export type DriverMaxAggregateOutputType = {
    uuid: string | null
    userId: string | null
    drivingLicenceNumber: string | null
    expiryDate: Date | null
    state: string | null
  }

  export type DriverCountAggregateOutputType = {
    uuid: number
    userId: number
    drivingLicenceNumber: number
    expiryDate: number
    state: number
    _all: number
  }


  export type DriverMinAggregateInputType = {
    uuid?: true
    userId?: true
    drivingLicenceNumber?: true
    expiryDate?: true
    state?: true
  }

  export type DriverMaxAggregateInputType = {
    uuid?: true
    userId?: true
    drivingLicenceNumber?: true
    expiryDate?: true
    state?: true
  }

  export type DriverCountAggregateInputType = {
    uuid?: true
    userId?: true
    drivingLicenceNumber?: true
    expiryDate?: true
    state?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which driver to aggregate.
     */
    where?: driverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: driverOrderByWithRelationInput | driverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: driverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type driverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: driverWhereInput
    orderBy?: driverOrderByWithAggregationInput | driverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: driverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    uuid: string
    userId: string
    drivingLicenceNumber: string
    expiryDate: Date
    state: string
    _count: DriverCountAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends driverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type driverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    userId?: boolean
    drivingLicenceNumber?: boolean
    expiryDate?: boolean
    state?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type driverSelectScalar = {
    uuid?: boolean
    userId?: boolean
    drivingLicenceNumber?: boolean
    expiryDate?: boolean
    state?: boolean
  }

  export type driverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }


  export type $driverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "driver"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      userId: string
      drivingLicenceNumber: string
      expiryDate: Date
      state: string
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }


  type driverGetPayload<S extends boolean | null | undefined | driverDefaultArgs> = $Result.GetResult<Prisma.$driverPayload, S>

  type driverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<driverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface driverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['driver'], meta: { name: 'driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {driverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends driverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, driverFindUniqueArgs<ExtArgs>>
    ): Prisma__driverClient<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Driver that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {driverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends driverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, driverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__driverClient<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends driverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, driverFindFirstArgs<ExtArgs>>
    ): Prisma__driverClient<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends driverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, driverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__driverClient<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const driverWithUuidOnly = await prisma.driver.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends driverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, driverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Driver.
     * @param {driverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
    **/
    create<T extends driverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, driverCreateArgs<ExtArgs>>
    ): Prisma__driverClient<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Drivers.
     *     @param {driverCreateManyArgs} args - Arguments to create many Drivers.
     *     @example
     *     // Create many Drivers
     *     const driver = await prisma.driver.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends driverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, driverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Driver.
     * @param {driverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
    **/
    delete<T extends driverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, driverDeleteArgs<ExtArgs>>
    ): Prisma__driverClient<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Driver.
     * @param {driverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends driverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, driverUpdateArgs<ExtArgs>>
    ): Prisma__driverClient<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Drivers.
     * @param {driverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends driverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, driverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends driverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, driverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Driver.
     * @param {driverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
    **/
    upsert<T extends driverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, driverUpsertArgs<ExtArgs>>
    ): Prisma__driverClient<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends driverCountArgs>(
      args?: Subset<T, driverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends driverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: driverGroupByArgs['orderBy'] }
        : { orderBy?: driverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, driverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the driver model
   */
  readonly fields: driverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__driverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the driver model
   */ 
  interface driverFieldRefs {
    readonly uuid: FieldRef<"driver", 'String'>
    readonly userId: FieldRef<"driver", 'String'>
    readonly drivingLicenceNumber: FieldRef<"driver", 'String'>
    readonly expiryDate: FieldRef<"driver", 'DateTime'>
    readonly state: FieldRef<"driver", 'String'>
  }
    

  // Custom InputTypes

  /**
   * driver findUnique
   */
  export type driverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    /**
     * Filter, which driver to fetch.
     */
    where: driverWhereUniqueInput
  }


  /**
   * driver findUniqueOrThrow
   */
  export type driverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    /**
     * Filter, which driver to fetch.
     */
    where: driverWhereUniqueInput
  }


  /**
   * driver findFirst
   */
  export type driverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    /**
     * Filter, which driver to fetch.
     */
    where?: driverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: driverOrderByWithRelationInput | driverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivers.
     */
    cursor?: driverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }


  /**
   * driver findFirstOrThrow
   */
  export type driverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    /**
     * Filter, which driver to fetch.
     */
    where?: driverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: driverOrderByWithRelationInput | driverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivers.
     */
    cursor?: driverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }


  /**
   * driver findMany
   */
  export type driverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    /**
     * Filter, which drivers to fetch.
     */
    where?: driverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: driverOrderByWithRelationInput | driverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drivers.
     */
    cursor?: driverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }


  /**
   * driver create
   */
  export type driverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    /**
     * The data needed to create a driver.
     */
    data: XOR<driverCreateInput, driverUncheckedCreateInput>
  }


  /**
   * driver createMany
   */
  export type driverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many drivers.
     */
    data: driverCreateManyInput | driverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * driver update
   */
  export type driverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    /**
     * The data needed to update a driver.
     */
    data: XOR<driverUpdateInput, driverUncheckedUpdateInput>
    /**
     * Choose, which driver to update.
     */
    where: driverWhereUniqueInput
  }


  /**
   * driver updateMany
   */
  export type driverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update drivers.
     */
    data: XOR<driverUpdateManyMutationInput, driverUncheckedUpdateManyInput>
    /**
     * Filter which drivers to update
     */
    where?: driverWhereInput
  }


  /**
   * driver upsert
   */
  export type driverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    /**
     * The filter to search for the driver to update in case it exists.
     */
    where: driverWhereUniqueInput
    /**
     * In case the driver found by the `where` argument doesn't exist, create a new driver with this data.
     */
    create: XOR<driverCreateInput, driverUncheckedCreateInput>
    /**
     * In case the driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<driverUpdateInput, driverUncheckedUpdateInput>
  }


  /**
   * driver delete
   */
  export type driverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    /**
     * Filter which driver to delete.
     */
    where: driverWhereUniqueInput
  }


  /**
   * driver deleteMany
   */
  export type driverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drivers to delete
     */
    where?: driverWhereInput
  }


  /**
   * driver without action
   */
  export type driverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
  }



  /**
   * Model drivershift
   */

  export type AggregateDrivershift = {
    _count: DrivershiftCountAggregateOutputType | null
    _min: DrivershiftMinAggregateOutputType | null
    _max: DrivershiftMaxAggregateOutputType | null
  }

  export type DrivershiftMinAggregateOutputType = {
    uuid: string | null
    driverId: string | null
    carId: string | null
    shiftStartTime: Date | null
    shiftEndTime: Date | null
    createdAt: Date | null
  }

  export type DrivershiftMaxAggregateOutputType = {
    uuid: string | null
    driverId: string | null
    carId: string | null
    shiftStartTime: Date | null
    shiftEndTime: Date | null
    createdAt: Date | null
  }

  export type DrivershiftCountAggregateOutputType = {
    uuid: number
    driverId: number
    carId: number
    shiftStartTime: number
    shiftEndTime: number
    createdAt: number
    _all: number
  }


  export type DrivershiftMinAggregateInputType = {
    uuid?: true
    driverId?: true
    carId?: true
    shiftStartTime?: true
    shiftEndTime?: true
    createdAt?: true
  }

  export type DrivershiftMaxAggregateInputType = {
    uuid?: true
    driverId?: true
    carId?: true
    shiftStartTime?: true
    shiftEndTime?: true
    createdAt?: true
  }

  export type DrivershiftCountAggregateInputType = {
    uuid?: true
    driverId?: true
    carId?: true
    shiftStartTime?: true
    shiftEndTime?: true
    createdAt?: true
    _all?: true
  }

  export type DrivershiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drivershift to aggregate.
     */
    where?: drivershiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivershifts to fetch.
     */
    orderBy?: drivershiftOrderByWithRelationInput | drivershiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: drivershiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivershifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivershifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drivershifts
    **/
    _count?: true | DrivershiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrivershiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrivershiftMaxAggregateInputType
  }

  export type GetDrivershiftAggregateType<T extends DrivershiftAggregateArgs> = {
        [P in keyof T & keyof AggregateDrivershift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrivershift[P]>
      : GetScalarType<T[P], AggregateDrivershift[P]>
  }




  export type drivershiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: drivershiftWhereInput
    orderBy?: drivershiftOrderByWithAggregationInput | drivershiftOrderByWithAggregationInput[]
    by: DrivershiftScalarFieldEnum[] | DrivershiftScalarFieldEnum
    having?: drivershiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrivershiftCountAggregateInputType | true
    _min?: DrivershiftMinAggregateInputType
    _max?: DrivershiftMaxAggregateInputType
  }

  export type DrivershiftGroupByOutputType = {
    uuid: string
    driverId: string
    carId: string
    shiftStartTime: Date
    shiftEndTime: Date
    createdAt: Date | null
    _count: DrivershiftCountAggregateOutputType | null
    _min: DrivershiftMinAggregateOutputType | null
    _max: DrivershiftMaxAggregateOutputType | null
  }

  type GetDrivershiftGroupByPayload<T extends drivershiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DrivershiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrivershiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrivershiftGroupByOutputType[P]>
            : GetScalarType<T[P], DrivershiftGroupByOutputType[P]>
        }
      >
    >


  export type drivershiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    driverId?: boolean
    carId?: boolean
    shiftStartTime?: boolean
    shiftEndTime?: boolean
    createdAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    car?: boolean | carDefaultArgs<ExtArgs>
    ridestatus?: boolean | drivershift$ridestatusArgs<ExtArgs>
    _count?: boolean | DrivershiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drivershift"]>

  export type drivershiftSelectScalar = {
    uuid?: boolean
    driverId?: boolean
    carId?: boolean
    shiftStartTime?: boolean
    shiftEndTime?: boolean
    createdAt?: boolean
  }

  export type drivershiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    car?: boolean | carDefaultArgs<ExtArgs>
    ridestatus?: boolean | drivershift$ridestatusArgs<ExtArgs>
    _count?: boolean | DrivershiftCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $drivershiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "drivershift"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      car: Prisma.$carPayload<ExtArgs>
      ridestatus: Prisma.$ridestatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      driverId: string
      carId: string
      shiftStartTime: Date
      shiftEndTime: Date
      createdAt: Date | null
    }, ExtArgs["result"]["drivershift"]>
    composites: {}
  }


  type drivershiftGetPayload<S extends boolean | null | undefined | drivershiftDefaultArgs> = $Result.GetResult<Prisma.$drivershiftPayload, S>

  type drivershiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<drivershiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DrivershiftCountAggregateInputType | true
    }

  export interface drivershiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['drivershift'], meta: { name: 'drivershift' } }
    /**
     * Find zero or one Drivershift that matches the filter.
     * @param {drivershiftFindUniqueArgs} args - Arguments to find a Drivershift
     * @example
     * // Get one Drivershift
     * const drivershift = await prisma.drivershift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends drivershiftFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, drivershiftFindUniqueArgs<ExtArgs>>
    ): Prisma__drivershiftClient<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Drivershift that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {drivershiftFindUniqueOrThrowArgs} args - Arguments to find a Drivershift
     * @example
     * // Get one Drivershift
     * const drivershift = await prisma.drivershift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends drivershiftFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, drivershiftFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__drivershiftClient<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Drivershift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drivershiftFindFirstArgs} args - Arguments to find a Drivershift
     * @example
     * // Get one Drivershift
     * const drivershift = await prisma.drivershift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends drivershiftFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, drivershiftFindFirstArgs<ExtArgs>>
    ): Prisma__drivershiftClient<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Drivershift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drivershiftFindFirstOrThrowArgs} args - Arguments to find a Drivershift
     * @example
     * // Get one Drivershift
     * const drivershift = await prisma.drivershift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends drivershiftFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, drivershiftFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__drivershiftClient<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Drivershifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drivershiftFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivershifts
     * const drivershifts = await prisma.drivershift.findMany()
     * 
     * // Get first 10 Drivershifts
     * const drivershifts = await prisma.drivershift.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const drivershiftWithUuidOnly = await prisma.drivershift.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends drivershiftFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, drivershiftFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Drivershift.
     * @param {drivershiftCreateArgs} args - Arguments to create a Drivershift.
     * @example
     * // Create one Drivershift
     * const Drivershift = await prisma.drivershift.create({
     *   data: {
     *     // ... data to create a Drivershift
     *   }
     * })
     * 
    **/
    create<T extends drivershiftCreateArgs<ExtArgs>>(
      args: SelectSubset<T, drivershiftCreateArgs<ExtArgs>>
    ): Prisma__drivershiftClient<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Drivershifts.
     *     @param {drivershiftCreateManyArgs} args - Arguments to create many Drivershifts.
     *     @example
     *     // Create many Drivershifts
     *     const drivershift = await prisma.drivershift.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends drivershiftCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, drivershiftCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Drivershift.
     * @param {drivershiftDeleteArgs} args - Arguments to delete one Drivershift.
     * @example
     * // Delete one Drivershift
     * const Drivershift = await prisma.drivershift.delete({
     *   where: {
     *     // ... filter to delete one Drivershift
     *   }
     * })
     * 
    **/
    delete<T extends drivershiftDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, drivershiftDeleteArgs<ExtArgs>>
    ): Prisma__drivershiftClient<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Drivershift.
     * @param {drivershiftUpdateArgs} args - Arguments to update one Drivershift.
     * @example
     * // Update one Drivershift
     * const drivershift = await prisma.drivershift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends drivershiftUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, drivershiftUpdateArgs<ExtArgs>>
    ): Prisma__drivershiftClient<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Drivershifts.
     * @param {drivershiftDeleteManyArgs} args - Arguments to filter Drivershifts to delete.
     * @example
     * // Delete a few Drivershifts
     * const { count } = await prisma.drivershift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends drivershiftDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, drivershiftDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivershifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drivershiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivershifts
     * const drivershift = await prisma.drivershift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends drivershiftUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, drivershiftUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Drivershift.
     * @param {drivershiftUpsertArgs} args - Arguments to update or create a Drivershift.
     * @example
     * // Update or create a Drivershift
     * const drivershift = await prisma.drivershift.upsert({
     *   create: {
     *     // ... data to create a Drivershift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drivershift we want to update
     *   }
     * })
    **/
    upsert<T extends drivershiftUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, drivershiftUpsertArgs<ExtArgs>>
    ): Prisma__drivershiftClient<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Drivershifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drivershiftCountArgs} args - Arguments to filter Drivershifts to count.
     * @example
     * // Count the number of Drivershifts
     * const count = await prisma.drivershift.count({
     *   where: {
     *     // ... the filter for the Drivershifts we want to count
     *   }
     * })
    **/
    count<T extends drivershiftCountArgs>(
      args?: Subset<T, drivershiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrivershiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drivershift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrivershiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrivershiftAggregateArgs>(args: Subset<T, DrivershiftAggregateArgs>): Prisma.PrismaPromise<GetDrivershiftAggregateType<T>>

    /**
     * Group by Drivershift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drivershiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends drivershiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: drivershiftGroupByArgs['orderBy'] }
        : { orderBy?: drivershiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, drivershiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrivershiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the drivershift model
   */
  readonly fields: drivershiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for drivershift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__drivershiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    car<T extends carDefaultArgs<ExtArgs> = {}>(args?: Subset<T, carDefaultArgs<ExtArgs>>): Prisma__carClient<$Result.GetResult<Prisma.$carPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ridestatus<T extends drivershift$ridestatusArgs<ExtArgs> = {}>(args?: Subset<T, drivershift$ridestatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the drivershift model
   */ 
  interface drivershiftFieldRefs {
    readonly uuid: FieldRef<"drivershift", 'String'>
    readonly driverId: FieldRef<"drivershift", 'String'>
    readonly carId: FieldRef<"drivershift", 'String'>
    readonly shiftStartTime: FieldRef<"drivershift", 'DateTime'>
    readonly shiftEndTime: FieldRef<"drivershift", 'DateTime'>
    readonly createdAt: FieldRef<"drivershift", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * drivershift findUnique
   */
  export type drivershiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    /**
     * Filter, which drivershift to fetch.
     */
    where: drivershiftWhereUniqueInput
  }


  /**
   * drivershift findUniqueOrThrow
   */
  export type drivershiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    /**
     * Filter, which drivershift to fetch.
     */
    where: drivershiftWhereUniqueInput
  }


  /**
   * drivershift findFirst
   */
  export type drivershiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    /**
     * Filter, which drivershift to fetch.
     */
    where?: drivershiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivershifts to fetch.
     */
    orderBy?: drivershiftOrderByWithRelationInput | drivershiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivershifts.
     */
    cursor?: drivershiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivershifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivershifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drivershifts.
     */
    distinct?: DrivershiftScalarFieldEnum | DrivershiftScalarFieldEnum[]
  }


  /**
   * drivershift findFirstOrThrow
   */
  export type drivershiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    /**
     * Filter, which drivershift to fetch.
     */
    where?: drivershiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivershifts to fetch.
     */
    orderBy?: drivershiftOrderByWithRelationInput | drivershiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivershifts.
     */
    cursor?: drivershiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivershifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivershifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drivershifts.
     */
    distinct?: DrivershiftScalarFieldEnum | DrivershiftScalarFieldEnum[]
  }


  /**
   * drivershift findMany
   */
  export type drivershiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    /**
     * Filter, which drivershifts to fetch.
     */
    where?: drivershiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivershifts to fetch.
     */
    orderBy?: drivershiftOrderByWithRelationInput | drivershiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drivershifts.
     */
    cursor?: drivershiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivershifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivershifts.
     */
    skip?: number
    distinct?: DrivershiftScalarFieldEnum | DrivershiftScalarFieldEnum[]
  }


  /**
   * drivershift create
   */
  export type drivershiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    /**
     * The data needed to create a drivershift.
     */
    data: XOR<drivershiftCreateInput, drivershiftUncheckedCreateInput>
  }


  /**
   * drivershift createMany
   */
  export type drivershiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many drivershifts.
     */
    data: drivershiftCreateManyInput | drivershiftCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * drivershift update
   */
  export type drivershiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    /**
     * The data needed to update a drivershift.
     */
    data: XOR<drivershiftUpdateInput, drivershiftUncheckedUpdateInput>
    /**
     * Choose, which drivershift to update.
     */
    where: drivershiftWhereUniqueInput
  }


  /**
   * drivershift updateMany
   */
  export type drivershiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update drivershifts.
     */
    data: XOR<drivershiftUpdateManyMutationInput, drivershiftUncheckedUpdateManyInput>
    /**
     * Filter which drivershifts to update
     */
    where?: drivershiftWhereInput
  }


  /**
   * drivershift upsert
   */
  export type drivershiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    /**
     * The filter to search for the drivershift to update in case it exists.
     */
    where: drivershiftWhereUniqueInput
    /**
     * In case the drivershift found by the `where` argument doesn't exist, create a new drivershift with this data.
     */
    create: XOR<drivershiftCreateInput, drivershiftUncheckedCreateInput>
    /**
     * In case the drivershift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<drivershiftUpdateInput, drivershiftUncheckedUpdateInput>
  }


  /**
   * drivershift delete
   */
  export type drivershiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    /**
     * Filter which drivershift to delete.
     */
    where: drivershiftWhereUniqueInput
  }


  /**
   * drivershift deleteMany
   */
  export type drivershiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drivershifts to delete
     */
    where?: drivershiftWhereInput
  }


  /**
   * drivershift.ridestatus
   */
  export type drivershift$ridestatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    where?: ridestatusWhereInput
    orderBy?: ridestatusOrderByWithRelationInput | ridestatusOrderByWithRelationInput[]
    cursor?: ridestatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RidestatusScalarFieldEnum | RidestatusScalarFieldEnum[]
  }


  /**
   * drivershift without action
   */
  export type drivershiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
  }



  /**
   * Model message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    uuid: string | null
    rideId: string | null
    senderId: string | null
    receiverId: string | null
    sendingTime: Date | null
    message: string | null
  }

  export type MessageMaxAggregateOutputType = {
    uuid: string | null
    rideId: string | null
    senderId: string | null
    receiverId: string | null
    sendingTime: Date | null
    message: string | null
  }

  export type MessageCountAggregateOutputType = {
    uuid: number
    rideId: number
    senderId: number
    receiverId: number
    sendingTime: number
    message: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    uuid?: true
    rideId?: true
    senderId?: true
    receiverId?: true
    sendingTime?: true
    message?: true
  }

  export type MessageMaxAggregateInputType = {
    uuid?: true
    rideId?: true
    senderId?: true
    receiverId?: true
    sendingTime?: true
    message?: true
  }

  export type MessageCountAggregateInputType = {
    uuid?: true
    rideId?: true
    senderId?: true
    receiverId?: true
    sendingTime?: true
    message?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message to aggregate.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
    orderBy?: messageOrderByWithAggregationInput | messageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    uuid: string
    rideId: string
    senderId: string
    receiverId: string
    sendingTime: Date
    message: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    rideId?: boolean
    senderId?: boolean
    receiverId?: boolean
    sendingTime?: boolean
    message?: boolean
    ride?: boolean | rideDefaultArgs<ExtArgs>
    user_message_senderIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_message_receiverIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectScalar = {
    uuid?: boolean
    rideId?: boolean
    senderId?: boolean
    receiverId?: boolean
    sendingTime?: boolean
    message?: boolean
  }

  export type messageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | rideDefaultArgs<ExtArgs>
    user_message_senderIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_message_receiverIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }


  export type $messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message"
    objects: {
      ride: Prisma.$ridePayload<ExtArgs>
      user_message_senderIdTouser: Prisma.$userPayload<ExtArgs>
      user_message_receiverIdTouser: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      rideId: string
      senderId: string
      receiverId: string
      sendingTime: Date
      message: string
    }, ExtArgs["result"]["message"]>
    composites: {}
  }


  type messageGetPayload<S extends boolean | null | undefined | messageDefaultArgs> = $Result.GetResult<Prisma.$messagePayload, S>

  type messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<messageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message'], meta: { name: 'message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {messageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends messageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, messageFindUniqueArgs<ExtArgs>>
    ): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {messageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends messageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, messageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends messageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, messageFindFirstArgs<ExtArgs>>
    ): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends messageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, messageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const messageWithUuidOnly = await prisma.message.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends messageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, messageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Message.
     * @param {messageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends messageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, messageCreateArgs<ExtArgs>>
    ): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messages.
     *     @param {messageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends messageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, messageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {messageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends messageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, messageDeleteArgs<ExtArgs>>
    ): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {messageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends messageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, messageUpdateArgs<ExtArgs>>
    ): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {messageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends messageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, messageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends messageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, messageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {messageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends messageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, messageUpsertArgs<ExtArgs>>
    ): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messageCountArgs>(
      args?: Subset<T, messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messageGroupByArgs['orderBy'] }
        : { orderBy?: messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message model
   */
  readonly fields: messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ride<T extends rideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rideDefaultArgs<ExtArgs>>): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user_message_senderIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user_message_receiverIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the message model
   */ 
  interface messageFieldRefs {
    readonly uuid: FieldRef<"message", 'String'>
    readonly rideId: FieldRef<"message", 'String'>
    readonly senderId: FieldRef<"message", 'String'>
    readonly receiverId: FieldRef<"message", 'String'>
    readonly sendingTime: FieldRef<"message", 'DateTime'>
    readonly message: FieldRef<"message", 'String'>
  }
    

  // Custom InputTypes

  /**
   * message findUnique
   */
  export type messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }


  /**
   * message findUniqueOrThrow
   */
  export type messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }


  /**
   * message findFirst
   */
  export type messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * message findFirstOrThrow
   */
  export type messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * message findMany
   */
  export type messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * message create
   */
  export type messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to create a message.
     */
    data: XOR<messageCreateInput, messageUncheckedCreateInput>
  }


  /**
   * message createMany
   */
  export type messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * message update
   */
  export type messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to update a message.
     */
    data: XOR<messageUpdateInput, messageUncheckedUpdateInput>
    /**
     * Choose, which message to update.
     */
    where: messageWhereUniqueInput
  }


  /**
   * message updateMany
   */
  export type messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
  }


  /**
   * message upsert
   */
  export type messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The filter to search for the message to update in case it exists.
     */
    where: messageWhereUniqueInput
    /**
     * In case the message found by the `where` argument doesn't exist, create a new message with this data.
     */
    create: XOR<messageCreateInput, messageUncheckedCreateInput>
    /**
     * In case the message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messageUpdateInput, messageUncheckedUpdateInput>
  }


  /**
   * message delete
   */
  export type messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter which message to delete.
     */
    where: messageWhereUniqueInput
  }


  /**
   * message deleteMany
   */
  export type messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messageWhereInput
  }


  /**
   * message without action
   */
  export type messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
  }



  /**
   * Model rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    ratingValue: number | null
  }

  export type RatingSumAggregateOutputType = {
    ratingValue: number | null
  }

  export type RatingMinAggregateOutputType = {
    uuid: string | null
    rideId: string | null
    driverId: string | null
    userId: string | null
    ratingComment: string | null
    ratingTag: string | null
    ratingValue: number | null
    ratingTime: Date | null
  }

  export type RatingMaxAggregateOutputType = {
    uuid: string | null
    rideId: string | null
    driverId: string | null
    userId: string | null
    ratingComment: string | null
    ratingTag: string | null
    ratingValue: number | null
    ratingTime: Date | null
  }

  export type RatingCountAggregateOutputType = {
    uuid: number
    rideId: number
    driverId: number
    userId: number
    ratingComment: number
    ratingTag: number
    ratingValue: number
    ratingTime: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    ratingValue?: true
  }

  export type RatingSumAggregateInputType = {
    ratingValue?: true
  }

  export type RatingMinAggregateInputType = {
    uuid?: true
    rideId?: true
    driverId?: true
    userId?: true
    ratingComment?: true
    ratingTag?: true
    ratingValue?: true
    ratingTime?: true
  }

  export type RatingMaxAggregateInputType = {
    uuid?: true
    rideId?: true
    driverId?: true
    userId?: true
    ratingComment?: true
    ratingTag?: true
    ratingValue?: true
    ratingTime?: true
  }

  export type RatingCountAggregateInputType = {
    uuid?: true
    rideId?: true
    driverId?: true
    userId?: true
    ratingComment?: true
    ratingTag?: true
    ratingValue?: true
    ratingTime?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rating to aggregate.
     */
    where?: ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type ratingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingWhereInput
    orderBy?: ratingOrderByWithAggregationInput | ratingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: ratingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    uuid: string
    rideId: string
    driverId: string
    userId: string
    ratingComment: string | null
    ratingTag: string | null
    ratingValue: number
    ratingTime: Date
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends ratingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type ratingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    rideId?: boolean
    driverId?: boolean
    userId?: boolean
    ratingComment?: boolean
    ratingTag?: boolean
    ratingValue?: boolean
    ratingTime?: boolean
    ride?: boolean | rideDefaultArgs<ExtArgs>
    user_rating_driverIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_rating_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type ratingSelectScalar = {
    uuid?: boolean
    rideId?: boolean
    driverId?: boolean
    userId?: boolean
    ratingComment?: boolean
    ratingTag?: boolean
    ratingValue?: boolean
    ratingTime?: boolean
  }

  export type ratingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | rideDefaultArgs<ExtArgs>
    user_rating_driverIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_rating_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }


  export type $ratingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rating"
    objects: {
      ride: Prisma.$ridePayload<ExtArgs>
      user_rating_driverIdTouser: Prisma.$userPayload<ExtArgs>
      user_rating_userIdTouser: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      rideId: string
      driverId: string
      userId: string
      ratingComment: string | null
      ratingTag: string | null
      ratingValue: number
      ratingTime: Date
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }


  type ratingGetPayload<S extends boolean | null | undefined | ratingDefaultArgs> = $Result.GetResult<Prisma.$ratingPayload, S>

  type ratingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ratingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface ratingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rating'], meta: { name: 'rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {ratingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ratingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ratingFindUniqueArgs<ExtArgs>>
    ): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rating that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ratingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ratingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ratingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ratingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ratingFindFirstArgs<ExtArgs>>
    ): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ratingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ratingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const ratingWithUuidOnly = await prisma.rating.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends ratingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ratingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rating.
     * @param {ratingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
    **/
    create<T extends ratingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ratingCreateArgs<ExtArgs>>
    ): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ratings.
     *     @param {ratingCreateManyArgs} args - Arguments to create many Ratings.
     *     @example
     *     // Create many Ratings
     *     const rating = await prisma.rating.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ratingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ratingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rating.
     * @param {ratingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
    **/
    delete<T extends ratingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ratingDeleteArgs<ExtArgs>>
    ): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rating.
     * @param {ratingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ratingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ratingUpdateArgs<ExtArgs>>
    ): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ratings.
     * @param {ratingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ratingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ratingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ratingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ratingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating.
     * @param {ratingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
    **/
    upsert<T extends ratingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ratingUpsertArgs<ExtArgs>>
    ): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends ratingCountArgs>(
      args?: Subset<T, ratingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ratingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ratingGroupByArgs['orderBy'] }
        : { orderBy?: ratingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ratingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rating model
   */
  readonly fields: ratingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ratingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ride<T extends rideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rideDefaultArgs<ExtArgs>>): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user_rating_driverIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user_rating_userIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rating model
   */ 
  interface ratingFieldRefs {
    readonly uuid: FieldRef<"rating", 'String'>
    readonly rideId: FieldRef<"rating", 'String'>
    readonly driverId: FieldRef<"rating", 'String'>
    readonly userId: FieldRef<"rating", 'String'>
    readonly ratingComment: FieldRef<"rating", 'String'>
    readonly ratingTag: FieldRef<"rating", 'String'>
    readonly ratingValue: FieldRef<"rating", 'Int'>
    readonly ratingTime: FieldRef<"rating", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * rating findUnique
   */
  export type ratingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which rating to fetch.
     */
    where: ratingWhereUniqueInput
  }


  /**
   * rating findUniqueOrThrow
   */
  export type ratingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which rating to fetch.
     */
    where: ratingWhereUniqueInput
  }


  /**
   * rating findFirst
   */
  export type ratingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which rating to fetch.
     */
    where?: ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * rating findFirstOrThrow
   */
  export type ratingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which rating to fetch.
     */
    where?: ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * rating findMany
   */
  export type ratingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ratings.
     */
    cursor?: ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * rating create
   */
  export type ratingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * The data needed to create a rating.
     */
    data: XOR<ratingCreateInput, ratingUncheckedCreateInput>
  }


  /**
   * rating createMany
   */
  export type ratingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ratings.
     */
    data: ratingCreateManyInput | ratingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rating update
   */
  export type ratingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * The data needed to update a rating.
     */
    data: XOR<ratingUpdateInput, ratingUncheckedUpdateInput>
    /**
     * Choose, which rating to update.
     */
    where: ratingWhereUniqueInput
  }


  /**
   * rating updateMany
   */
  export type ratingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ratings.
     */
    data: XOR<ratingUpdateManyMutationInput, ratingUncheckedUpdateManyInput>
    /**
     * Filter which ratings to update
     */
    where?: ratingWhereInput
  }


  /**
   * rating upsert
   */
  export type ratingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * The filter to search for the rating to update in case it exists.
     */
    where: ratingWhereUniqueInput
    /**
     * In case the rating found by the `where` argument doesn't exist, create a new rating with this data.
     */
    create: XOR<ratingCreateInput, ratingUncheckedCreateInput>
    /**
     * In case the rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ratingUpdateInput, ratingUncheckedUpdateInput>
  }


  /**
   * rating delete
   */
  export type ratingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter which rating to delete.
     */
    where: ratingWhereUniqueInput
  }


  /**
   * rating deleteMany
   */
  export type ratingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ratings to delete
     */
    where?: ratingWhereInput
  }


  /**
   * rating without action
   */
  export type ratingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
  }



  /**
   * Model ride
   */

  export type AggregateRide = {
    _count: RideCountAggregateOutputType | null
    _avg: RideAvgAggregateOutputType | null
    _sum: RideSumAggregateOutputType | null
    _min: RideMinAggregateOutputType | null
    _max: RideMaxAggregateOutputType | null
  }

  export type RideAvgAggregateOutputType = {
    seat: number | null
    distance: number | null
    price: number | null
  }

  export type RideSumAggregateOutputType = {
    seat: number | null
    distance: number | null
    price: number | null
  }

  export type RideMinAggregateOutputType = {
    uuid: string | null
    fullName: string | null
    gender: string | null
    phone: string | null
    seat: number | null
    rideStartTime: Date | null
    rideEndTime: Date | null
    startingPoint: string | null
    destinationPoint: string | null
    distance: number | null
    price: number | null
    note: string | null
  }

  export type RideMaxAggregateOutputType = {
    uuid: string | null
    fullName: string | null
    gender: string | null
    phone: string | null
    seat: number | null
    rideStartTime: Date | null
    rideEndTime: Date | null
    startingPoint: string | null
    destinationPoint: string | null
    distance: number | null
    price: number | null
    note: string | null
  }

  export type RideCountAggregateOutputType = {
    uuid: number
    fullName: number
    gender: number
    phone: number
    seat: number
    rideStartTime: number
    rideEndTime: number
    startingPoint: number
    destinationPoint: number
    distance: number
    price: number
    note: number
    _all: number
  }


  export type RideAvgAggregateInputType = {
    seat?: true
    distance?: true
    price?: true
  }

  export type RideSumAggregateInputType = {
    seat?: true
    distance?: true
    price?: true
  }

  export type RideMinAggregateInputType = {
    uuid?: true
    fullName?: true
    gender?: true
    phone?: true
    seat?: true
    rideStartTime?: true
    rideEndTime?: true
    startingPoint?: true
    destinationPoint?: true
    distance?: true
    price?: true
    note?: true
  }

  export type RideMaxAggregateInputType = {
    uuid?: true
    fullName?: true
    gender?: true
    phone?: true
    seat?: true
    rideStartTime?: true
    rideEndTime?: true
    startingPoint?: true
    destinationPoint?: true
    distance?: true
    price?: true
    note?: true
  }

  export type RideCountAggregateInputType = {
    uuid?: true
    fullName?: true
    gender?: true
    phone?: true
    seat?: true
    rideStartTime?: true
    rideEndTime?: true
    startingPoint?: true
    destinationPoint?: true
    distance?: true
    price?: true
    note?: true
    _all?: true
  }

  export type RideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ride to aggregate.
     */
    where?: rideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rides to fetch.
     */
    orderBy?: rideOrderByWithRelationInput | rideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rides
    **/
    _count?: true | RideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RideMaxAggregateInputType
  }

  export type GetRideAggregateType<T extends RideAggregateArgs> = {
        [P in keyof T & keyof AggregateRide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRide[P]>
      : GetScalarType<T[P], AggregateRide[P]>
  }




  export type rideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rideWhereInput
    orderBy?: rideOrderByWithAggregationInput | rideOrderByWithAggregationInput[]
    by: RideScalarFieldEnum[] | RideScalarFieldEnum
    having?: rideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RideCountAggregateInputType | true
    _avg?: RideAvgAggregateInputType
    _sum?: RideSumAggregateInputType
    _min?: RideMinAggregateInputType
    _max?: RideMaxAggregateInputType
  }

  export type RideGroupByOutputType = {
    uuid: string
    fullName: string
    gender: string | null
    phone: string
    seat: number
    rideStartTime: Date
    rideEndTime: Date | null
    startingPoint: string
    destinationPoint: string
    distance: number | null
    price: number | null
    note: string | null
    _count: RideCountAggregateOutputType | null
    _avg: RideAvgAggregateOutputType | null
    _sum: RideSumAggregateOutputType | null
    _min: RideMinAggregateOutputType | null
    _max: RideMaxAggregateOutputType | null
  }

  type GetRideGroupByPayload<T extends rideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RideGroupByOutputType[P]>
            : GetScalarType<T[P], RideGroupByOutputType[P]>
        }
      >
    >


  export type rideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    fullName?: boolean
    gender?: boolean
    phone?: boolean
    seat?: boolean
    rideStartTime?: boolean
    rideEndTime?: boolean
    startingPoint?: boolean
    destinationPoint?: boolean
    distance?: boolean
    price?: boolean
    note?: boolean
    message?: boolean | ride$messageArgs<ExtArgs>
    rating?: boolean | ride$ratingArgs<ExtArgs>
    ridestatus?: boolean | ride$ridestatusArgs<ExtArgs>
    _count?: boolean | RideCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ride"]>

  export type rideSelectScalar = {
    uuid?: boolean
    fullName?: boolean
    gender?: boolean
    phone?: boolean
    seat?: boolean
    rideStartTime?: boolean
    rideEndTime?: boolean
    startingPoint?: boolean
    destinationPoint?: boolean
    distance?: boolean
    price?: boolean
    note?: boolean
  }

  export type rideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | ride$messageArgs<ExtArgs>
    rating?: boolean | ride$ratingArgs<ExtArgs>
    ridestatus?: boolean | ride$ridestatusArgs<ExtArgs>
    _count?: boolean | RideCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ridePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ride"
    objects: {
      message: Prisma.$messagePayload<ExtArgs>[]
      rating: Prisma.$ratingPayload<ExtArgs>[]
      ridestatus: Prisma.$ridestatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      fullName: string
      gender: string | null
      phone: string
      seat: number
      rideStartTime: Date
      rideEndTime: Date | null
      startingPoint: string
      destinationPoint: string
      distance: number | null
      price: number | null
      note: string | null
    }, ExtArgs["result"]["ride"]>
    composites: {}
  }


  type rideGetPayload<S extends boolean | null | undefined | rideDefaultArgs> = $Result.GetResult<Prisma.$ridePayload, S>

  type rideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RideCountAggregateInputType | true
    }

  export interface rideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ride'], meta: { name: 'ride' } }
    /**
     * Find zero or one Ride that matches the filter.
     * @param {rideFindUniqueArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rideFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rideFindUniqueArgs<ExtArgs>>
    ): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ride that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rideFindUniqueOrThrowArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rideFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rideFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rideFindFirstArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rideFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rideFindFirstArgs<ExtArgs>>
    ): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rideFindFirstOrThrowArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rideFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rideFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rideFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rides
     * const rides = await prisma.ride.findMany()
     * 
     * // Get first 10 Rides
     * const rides = await prisma.ride.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const rideWithUuidOnly = await prisma.ride.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends rideFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rideFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ride.
     * @param {rideCreateArgs} args - Arguments to create a Ride.
     * @example
     * // Create one Ride
     * const Ride = await prisma.ride.create({
     *   data: {
     *     // ... data to create a Ride
     *   }
     * })
     * 
    **/
    create<T extends rideCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rideCreateArgs<ExtArgs>>
    ): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rides.
     *     @param {rideCreateManyArgs} args - Arguments to create many Rides.
     *     @example
     *     // Create many Rides
     *     const ride = await prisma.ride.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rideCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rideCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ride.
     * @param {rideDeleteArgs} args - Arguments to delete one Ride.
     * @example
     * // Delete one Ride
     * const Ride = await prisma.ride.delete({
     *   where: {
     *     // ... filter to delete one Ride
     *   }
     * })
     * 
    **/
    delete<T extends rideDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rideDeleteArgs<ExtArgs>>
    ): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ride.
     * @param {rideUpdateArgs} args - Arguments to update one Ride.
     * @example
     * // Update one Ride
     * const ride = await prisma.ride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rideUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rideUpdateArgs<ExtArgs>>
    ): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rides.
     * @param {rideDeleteManyArgs} args - Arguments to filter Rides to delete.
     * @example
     * // Delete a few Rides
     * const { count } = await prisma.ride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rideDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rideDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rides
     * const ride = await prisma.ride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rideUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rideUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ride.
     * @param {rideUpsertArgs} args - Arguments to update or create a Ride.
     * @example
     * // Update or create a Ride
     * const ride = await prisma.ride.upsert({
     *   create: {
     *     // ... data to create a Ride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ride we want to update
     *   }
     * })
    **/
    upsert<T extends rideUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rideUpsertArgs<ExtArgs>>
    ): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rideCountArgs} args - Arguments to filter Rides to count.
     * @example
     * // Count the number of Rides
     * const count = await prisma.ride.count({
     *   where: {
     *     // ... the filter for the Rides we want to count
     *   }
     * })
    **/
    count<T extends rideCountArgs>(
      args?: Subset<T, rideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RideAggregateArgs>(args: Subset<T, RideAggregateArgs>): Prisma.PrismaPromise<GetRideAggregateType<T>>

    /**
     * Group by Ride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rideGroupByArgs['orderBy'] }
        : { orderBy?: rideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ride model
   */
  readonly fields: rideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    message<T extends ride$messageArgs<ExtArgs> = {}>(args?: Subset<T, ride$messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'findMany'> | Null>;

    rating<T extends ride$ratingArgs<ExtArgs> = {}>(args?: Subset<T, ride$ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'findMany'> | Null>;

    ridestatus<T extends ride$ridestatusArgs<ExtArgs> = {}>(args?: Subset<T, ride$ridestatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ride model
   */ 
  interface rideFieldRefs {
    readonly uuid: FieldRef<"ride", 'String'>
    readonly fullName: FieldRef<"ride", 'String'>
    readonly gender: FieldRef<"ride", 'String'>
    readonly phone: FieldRef<"ride", 'String'>
    readonly seat: FieldRef<"ride", 'Int'>
    readonly rideStartTime: FieldRef<"ride", 'DateTime'>
    readonly rideEndTime: FieldRef<"ride", 'DateTime'>
    readonly startingPoint: FieldRef<"ride", 'String'>
    readonly destinationPoint: FieldRef<"ride", 'String'>
    readonly distance: FieldRef<"ride", 'Float'>
    readonly price: FieldRef<"ride", 'Int'>
    readonly note: FieldRef<"ride", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ride findUnique
   */
  export type rideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
    /**
     * Filter, which ride to fetch.
     */
    where: rideWhereUniqueInput
  }


  /**
   * ride findUniqueOrThrow
   */
  export type rideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
    /**
     * Filter, which ride to fetch.
     */
    where: rideWhereUniqueInput
  }


  /**
   * ride findFirst
   */
  export type rideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
    /**
     * Filter, which ride to fetch.
     */
    where?: rideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rides to fetch.
     */
    orderBy?: rideOrderByWithRelationInput | rideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rides.
     */
    cursor?: rideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rides.
     */
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }


  /**
   * ride findFirstOrThrow
   */
  export type rideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
    /**
     * Filter, which ride to fetch.
     */
    where?: rideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rides to fetch.
     */
    orderBy?: rideOrderByWithRelationInput | rideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rides.
     */
    cursor?: rideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rides.
     */
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }


  /**
   * ride findMany
   */
  export type rideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
    /**
     * Filter, which rides to fetch.
     */
    where?: rideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rides to fetch.
     */
    orderBy?: rideOrderByWithRelationInput | rideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rides.
     */
    cursor?: rideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rides.
     */
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }


  /**
   * ride create
   */
  export type rideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
    /**
     * The data needed to create a ride.
     */
    data: XOR<rideCreateInput, rideUncheckedCreateInput>
  }


  /**
   * ride createMany
   */
  export type rideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rides.
     */
    data: rideCreateManyInput | rideCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ride update
   */
  export type rideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
    /**
     * The data needed to update a ride.
     */
    data: XOR<rideUpdateInput, rideUncheckedUpdateInput>
    /**
     * Choose, which ride to update.
     */
    where: rideWhereUniqueInput
  }


  /**
   * ride updateMany
   */
  export type rideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rides.
     */
    data: XOR<rideUpdateManyMutationInput, rideUncheckedUpdateManyInput>
    /**
     * Filter which rides to update
     */
    where?: rideWhereInput
  }


  /**
   * ride upsert
   */
  export type rideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
    /**
     * The filter to search for the ride to update in case it exists.
     */
    where: rideWhereUniqueInput
    /**
     * In case the ride found by the `where` argument doesn't exist, create a new ride with this data.
     */
    create: XOR<rideCreateInput, rideUncheckedCreateInput>
    /**
     * In case the ride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rideUpdateInput, rideUncheckedUpdateInput>
  }


  /**
   * ride delete
   */
  export type rideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
    /**
     * Filter which ride to delete.
     */
    where: rideWhereUniqueInput
  }


  /**
   * ride deleteMany
   */
  export type rideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rides to delete
     */
    where?: rideWhereInput
  }


  /**
   * ride.message
   */
  export type ride$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * ride.rating
   */
  export type ride$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    where?: ratingWhereInput
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    cursor?: ratingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * ride.ridestatus
   */
  export type ride$ridestatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    where?: ridestatusWhereInput
    orderBy?: ridestatusOrderByWithRelationInput | ridestatusOrderByWithRelationInput[]
    cursor?: ridestatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RidestatusScalarFieldEnum | RidestatusScalarFieldEnum[]
  }


  /**
   * ride without action
   */
  export type rideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ride
     */
    select?: rideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rideInclude<ExtArgs> | null
  }



  /**
   * Model ridestatus
   */

  export type AggregateRidestatus = {
    _count: RidestatusCountAggregateOutputType | null
    _min: RidestatusMinAggregateOutputType | null
    _max: RidestatusMaxAggregateOutputType | null
  }

  export type RidestatusMinAggregateOutputType = {
    uuid: string | null
    rideId: string | null
    driverId: string | null
    driverShiftId: string | null
    state: string | null
    stateTime: Date | null
    stateDetail: string | null
  }

  export type RidestatusMaxAggregateOutputType = {
    uuid: string | null
    rideId: string | null
    driverId: string | null
    driverShiftId: string | null
    state: string | null
    stateTime: Date | null
    stateDetail: string | null
  }

  export type RidestatusCountAggregateOutputType = {
    uuid: number
    rideId: number
    driverId: number
    driverShiftId: number
    state: number
    stateTime: number
    stateDetail: number
    _all: number
  }


  export type RidestatusMinAggregateInputType = {
    uuid?: true
    rideId?: true
    driverId?: true
    driverShiftId?: true
    state?: true
    stateTime?: true
    stateDetail?: true
  }

  export type RidestatusMaxAggregateInputType = {
    uuid?: true
    rideId?: true
    driverId?: true
    driverShiftId?: true
    state?: true
    stateTime?: true
    stateDetail?: true
  }

  export type RidestatusCountAggregateInputType = {
    uuid?: true
    rideId?: true
    driverId?: true
    driverShiftId?: true
    state?: true
    stateTime?: true
    stateDetail?: true
    _all?: true
  }

  export type RidestatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ridestatus to aggregate.
     */
    where?: ridestatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ridestatuses to fetch.
     */
    orderBy?: ridestatusOrderByWithRelationInput | ridestatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ridestatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ridestatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ridestatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ridestatuses
    **/
    _count?: true | RidestatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RidestatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RidestatusMaxAggregateInputType
  }

  export type GetRidestatusAggregateType<T extends RidestatusAggregateArgs> = {
        [P in keyof T & keyof AggregateRidestatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRidestatus[P]>
      : GetScalarType<T[P], AggregateRidestatus[P]>
  }




  export type ridestatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ridestatusWhereInput
    orderBy?: ridestatusOrderByWithAggregationInput | ridestatusOrderByWithAggregationInput[]
    by: RidestatusScalarFieldEnum[] | RidestatusScalarFieldEnum
    having?: ridestatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RidestatusCountAggregateInputType | true
    _min?: RidestatusMinAggregateInputType
    _max?: RidestatusMaxAggregateInputType
  }

  export type RidestatusGroupByOutputType = {
    uuid: string
    rideId: string
    driverId: string | null
    driverShiftId: string | null
    state: string
    stateTime: Date
    stateDetail: string | null
    _count: RidestatusCountAggregateOutputType | null
    _min: RidestatusMinAggregateOutputType | null
    _max: RidestatusMaxAggregateOutputType | null
  }

  type GetRidestatusGroupByPayload<T extends ridestatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RidestatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RidestatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RidestatusGroupByOutputType[P]>
            : GetScalarType<T[P], RidestatusGroupByOutputType[P]>
        }
      >
    >


  export type ridestatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    rideId?: boolean
    driverId?: boolean
    driverShiftId?: boolean
    state?: boolean
    stateTime?: boolean
    stateDetail?: boolean
    ride?: boolean | rideDefaultArgs<ExtArgs>
    user?: boolean | ridestatus$userArgs<ExtArgs>
    drivershift?: boolean | ridestatus$drivershiftArgs<ExtArgs>
  }, ExtArgs["result"]["ridestatus"]>

  export type ridestatusSelectScalar = {
    uuid?: boolean
    rideId?: boolean
    driverId?: boolean
    driverShiftId?: boolean
    state?: boolean
    stateTime?: boolean
    stateDetail?: boolean
  }

  export type ridestatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | rideDefaultArgs<ExtArgs>
    user?: boolean | ridestatus$userArgs<ExtArgs>
    drivershift?: boolean | ridestatus$drivershiftArgs<ExtArgs>
  }


  export type $ridestatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ridestatus"
    objects: {
      ride: Prisma.$ridePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs> | null
      drivershift: Prisma.$drivershiftPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      rideId: string
      driverId: string | null
      driverShiftId: string | null
      state: string
      stateTime: Date
      stateDetail: string | null
    }, ExtArgs["result"]["ridestatus"]>
    composites: {}
  }


  type ridestatusGetPayload<S extends boolean | null | undefined | ridestatusDefaultArgs> = $Result.GetResult<Prisma.$ridestatusPayload, S>

  type ridestatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ridestatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RidestatusCountAggregateInputType | true
    }

  export interface ridestatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ridestatus'], meta: { name: 'ridestatus' } }
    /**
     * Find zero or one Ridestatus that matches the filter.
     * @param {ridestatusFindUniqueArgs} args - Arguments to find a Ridestatus
     * @example
     * // Get one Ridestatus
     * const ridestatus = await prisma.ridestatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ridestatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ridestatusFindUniqueArgs<ExtArgs>>
    ): Prisma__ridestatusClient<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ridestatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ridestatusFindUniqueOrThrowArgs} args - Arguments to find a Ridestatus
     * @example
     * // Get one Ridestatus
     * const ridestatus = await prisma.ridestatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ridestatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ridestatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ridestatusClient<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ridestatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ridestatusFindFirstArgs} args - Arguments to find a Ridestatus
     * @example
     * // Get one Ridestatus
     * const ridestatus = await prisma.ridestatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ridestatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ridestatusFindFirstArgs<ExtArgs>>
    ): Prisma__ridestatusClient<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ridestatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ridestatusFindFirstOrThrowArgs} args - Arguments to find a Ridestatus
     * @example
     * // Get one Ridestatus
     * const ridestatus = await prisma.ridestatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ridestatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ridestatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ridestatusClient<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ridestatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ridestatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ridestatuses
     * const ridestatuses = await prisma.ridestatus.findMany()
     * 
     * // Get first 10 Ridestatuses
     * const ridestatuses = await prisma.ridestatus.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const ridestatusWithUuidOnly = await prisma.ridestatus.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends ridestatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ridestatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ridestatus.
     * @param {ridestatusCreateArgs} args - Arguments to create a Ridestatus.
     * @example
     * // Create one Ridestatus
     * const Ridestatus = await prisma.ridestatus.create({
     *   data: {
     *     // ... data to create a Ridestatus
     *   }
     * })
     * 
    **/
    create<T extends ridestatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ridestatusCreateArgs<ExtArgs>>
    ): Prisma__ridestatusClient<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ridestatuses.
     *     @param {ridestatusCreateManyArgs} args - Arguments to create many Ridestatuses.
     *     @example
     *     // Create many Ridestatuses
     *     const ridestatus = await prisma.ridestatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ridestatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ridestatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ridestatus.
     * @param {ridestatusDeleteArgs} args - Arguments to delete one Ridestatus.
     * @example
     * // Delete one Ridestatus
     * const Ridestatus = await prisma.ridestatus.delete({
     *   where: {
     *     // ... filter to delete one Ridestatus
     *   }
     * })
     * 
    **/
    delete<T extends ridestatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ridestatusDeleteArgs<ExtArgs>>
    ): Prisma__ridestatusClient<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ridestatus.
     * @param {ridestatusUpdateArgs} args - Arguments to update one Ridestatus.
     * @example
     * // Update one Ridestatus
     * const ridestatus = await prisma.ridestatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ridestatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ridestatusUpdateArgs<ExtArgs>>
    ): Prisma__ridestatusClient<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ridestatuses.
     * @param {ridestatusDeleteManyArgs} args - Arguments to filter Ridestatuses to delete.
     * @example
     * // Delete a few Ridestatuses
     * const { count } = await prisma.ridestatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ridestatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ridestatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ridestatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ridestatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ridestatuses
     * const ridestatus = await prisma.ridestatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ridestatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ridestatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ridestatus.
     * @param {ridestatusUpsertArgs} args - Arguments to update or create a Ridestatus.
     * @example
     * // Update or create a Ridestatus
     * const ridestatus = await prisma.ridestatus.upsert({
     *   create: {
     *     // ... data to create a Ridestatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ridestatus we want to update
     *   }
     * })
    **/
    upsert<T extends ridestatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ridestatusUpsertArgs<ExtArgs>>
    ): Prisma__ridestatusClient<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ridestatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ridestatusCountArgs} args - Arguments to filter Ridestatuses to count.
     * @example
     * // Count the number of Ridestatuses
     * const count = await prisma.ridestatus.count({
     *   where: {
     *     // ... the filter for the Ridestatuses we want to count
     *   }
     * })
    **/
    count<T extends ridestatusCountArgs>(
      args?: Subset<T, ridestatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RidestatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ridestatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidestatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RidestatusAggregateArgs>(args: Subset<T, RidestatusAggregateArgs>): Prisma.PrismaPromise<GetRidestatusAggregateType<T>>

    /**
     * Group by Ridestatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ridestatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ridestatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ridestatusGroupByArgs['orderBy'] }
        : { orderBy?: ridestatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ridestatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRidestatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ridestatus model
   */
  readonly fields: ridestatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ridestatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ridestatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ride<T extends rideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rideDefaultArgs<ExtArgs>>): Prisma__rideClient<$Result.GetResult<Prisma.$ridePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends ridestatus$userArgs<ExtArgs> = {}>(args?: Subset<T, ridestatus$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    drivershift<T extends ridestatus$drivershiftArgs<ExtArgs> = {}>(args?: Subset<T, ridestatus$drivershiftArgs<ExtArgs>>): Prisma__drivershiftClient<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ridestatus model
   */ 
  interface ridestatusFieldRefs {
    readonly uuid: FieldRef<"ridestatus", 'String'>
    readonly rideId: FieldRef<"ridestatus", 'String'>
    readonly driverId: FieldRef<"ridestatus", 'String'>
    readonly driverShiftId: FieldRef<"ridestatus", 'String'>
    readonly state: FieldRef<"ridestatus", 'String'>
    readonly stateTime: FieldRef<"ridestatus", 'DateTime'>
    readonly stateDetail: FieldRef<"ridestatus", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ridestatus findUnique
   */
  export type ridestatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    /**
     * Filter, which ridestatus to fetch.
     */
    where: ridestatusWhereUniqueInput
  }


  /**
   * ridestatus findUniqueOrThrow
   */
  export type ridestatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    /**
     * Filter, which ridestatus to fetch.
     */
    where: ridestatusWhereUniqueInput
  }


  /**
   * ridestatus findFirst
   */
  export type ridestatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    /**
     * Filter, which ridestatus to fetch.
     */
    where?: ridestatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ridestatuses to fetch.
     */
    orderBy?: ridestatusOrderByWithRelationInput | ridestatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ridestatuses.
     */
    cursor?: ridestatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ridestatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ridestatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ridestatuses.
     */
    distinct?: RidestatusScalarFieldEnum | RidestatusScalarFieldEnum[]
  }


  /**
   * ridestatus findFirstOrThrow
   */
  export type ridestatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    /**
     * Filter, which ridestatus to fetch.
     */
    where?: ridestatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ridestatuses to fetch.
     */
    orderBy?: ridestatusOrderByWithRelationInput | ridestatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ridestatuses.
     */
    cursor?: ridestatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ridestatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ridestatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ridestatuses.
     */
    distinct?: RidestatusScalarFieldEnum | RidestatusScalarFieldEnum[]
  }


  /**
   * ridestatus findMany
   */
  export type ridestatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    /**
     * Filter, which ridestatuses to fetch.
     */
    where?: ridestatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ridestatuses to fetch.
     */
    orderBy?: ridestatusOrderByWithRelationInput | ridestatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ridestatuses.
     */
    cursor?: ridestatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ridestatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ridestatuses.
     */
    skip?: number
    distinct?: RidestatusScalarFieldEnum | RidestatusScalarFieldEnum[]
  }


  /**
   * ridestatus create
   */
  export type ridestatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ridestatus.
     */
    data: XOR<ridestatusCreateInput, ridestatusUncheckedCreateInput>
  }


  /**
   * ridestatus createMany
   */
  export type ridestatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ridestatuses.
     */
    data: ridestatusCreateManyInput | ridestatusCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ridestatus update
   */
  export type ridestatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ridestatus.
     */
    data: XOR<ridestatusUpdateInput, ridestatusUncheckedUpdateInput>
    /**
     * Choose, which ridestatus to update.
     */
    where: ridestatusWhereUniqueInput
  }


  /**
   * ridestatus updateMany
   */
  export type ridestatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ridestatuses.
     */
    data: XOR<ridestatusUpdateManyMutationInput, ridestatusUncheckedUpdateManyInput>
    /**
     * Filter which ridestatuses to update
     */
    where?: ridestatusWhereInput
  }


  /**
   * ridestatus upsert
   */
  export type ridestatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ridestatus to update in case it exists.
     */
    where: ridestatusWhereUniqueInput
    /**
     * In case the ridestatus found by the `where` argument doesn't exist, create a new ridestatus with this data.
     */
    create: XOR<ridestatusCreateInput, ridestatusUncheckedCreateInput>
    /**
     * In case the ridestatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ridestatusUpdateInput, ridestatusUncheckedUpdateInput>
  }


  /**
   * ridestatus delete
   */
  export type ridestatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    /**
     * Filter which ridestatus to delete.
     */
    where: ridestatusWhereUniqueInput
  }


  /**
   * ridestatus deleteMany
   */
  export type ridestatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ridestatuses to delete
     */
    where?: ridestatusWhereInput
  }


  /**
   * ridestatus.user
   */
  export type ridestatus$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * ridestatus.drivershift
   */
  export type ridestatus$drivershiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    where?: drivershiftWhereInput
  }


  /**
   * ridestatus without action
   */
  export type ridestatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
  }



  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    uuid: string | null
    fullName: string | null
    gender: string | null
    address: string | null
    phone: string | null
    email: string | null
    password: string | null
    role: string | null
    dob: Date | null
    cic: string | null
    avatar: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    uuid: string | null
    fullName: string | null
    gender: string | null
    address: string | null
    phone: string | null
    email: string | null
    password: string | null
    role: string | null
    dob: Date | null
    cic: string | null
    avatar: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    uuid: number
    fullName: number
    gender: number
    address: number
    phone: number
    email: number
    password: number
    role: number
    dob: number
    cic: number
    avatar: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    uuid?: true
    fullName?: true
    gender?: true
    address?: true
    phone?: true
    email?: true
    password?: true
    role?: true
    dob?: true
    cic?: true
    avatar?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    uuid?: true
    fullName?: true
    gender?: true
    address?: true
    phone?: true
    email?: true
    password?: true
    role?: true
    dob?: true
    cic?: true
    avatar?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    uuid?: true
    fullName?: true
    gender?: true
    address?: true
    phone?: true
    email?: true
    password?: true
    role?: true
    dob?: true
    cic?: true
    avatar?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    uuid: string
    fullName: string
    gender: string | null
    address: string | null
    phone: string
    email: string | null
    password: string
    role: string
    dob: Date
    cic: string
    avatar: string
    createdAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    fullName?: boolean
    gender?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    dob?: boolean
    cic?: boolean
    avatar?: boolean
    createdAt?: boolean
    call_call_userCallIdTouser?: boolean | user$call_call_userCallIdTouserArgs<ExtArgs>
    call_call_userAnswerIdTouser?: boolean | user$call_call_userAnswerIdTouserArgs<ExtArgs>
    callcenteragent?: boolean | user$callcenteragentArgs<ExtArgs>
    customer?: boolean | user$customerArgs<ExtArgs>
    driver?: boolean | user$driverArgs<ExtArgs>
    drivershift?: boolean | user$drivershiftArgs<ExtArgs>
    message_message_senderIdTouser?: boolean | user$message_message_senderIdTouserArgs<ExtArgs>
    message_message_receiverIdTouser?: boolean | user$message_message_receiverIdTouserArgs<ExtArgs>
    rating_rating_driverIdTouser?: boolean | user$rating_rating_driverIdTouserArgs<ExtArgs>
    rating_rating_userIdTouser?: boolean | user$rating_rating_userIdTouserArgs<ExtArgs>
    ridestatus?: boolean | user$ridestatusArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    uuid?: boolean
    fullName?: boolean
    gender?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    dob?: boolean
    cic?: boolean
    avatar?: boolean
    createdAt?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    call_call_userCallIdTouser?: boolean | user$call_call_userCallIdTouserArgs<ExtArgs>
    call_call_userAnswerIdTouser?: boolean | user$call_call_userAnswerIdTouserArgs<ExtArgs>
    callcenteragent?: boolean | user$callcenteragentArgs<ExtArgs>
    customer?: boolean | user$customerArgs<ExtArgs>
    driver?: boolean | user$driverArgs<ExtArgs>
    drivershift?: boolean | user$drivershiftArgs<ExtArgs>
    message_message_senderIdTouser?: boolean | user$message_message_senderIdTouserArgs<ExtArgs>
    message_message_receiverIdTouser?: boolean | user$message_message_receiverIdTouserArgs<ExtArgs>
    rating_rating_driverIdTouser?: boolean | user$rating_rating_driverIdTouserArgs<ExtArgs>
    rating_rating_userIdTouser?: boolean | user$rating_rating_userIdTouserArgs<ExtArgs>
    ridestatus?: boolean | user$ridestatusArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      call_call_userCallIdTouser: Prisma.$callPayload<ExtArgs>[]
      call_call_userAnswerIdTouser: Prisma.$callPayload<ExtArgs>[]
      callcenteragent: Prisma.$callcenteragentPayload<ExtArgs>[]
      customer: Prisma.$customerPayload<ExtArgs>[]
      driver: Prisma.$driverPayload<ExtArgs>[]
      drivershift: Prisma.$drivershiftPayload<ExtArgs>[]
      message_message_senderIdTouser: Prisma.$messagePayload<ExtArgs>[]
      message_message_receiverIdTouser: Prisma.$messagePayload<ExtArgs>[]
      rating_rating_driverIdTouser: Prisma.$ratingPayload<ExtArgs>[]
      rating_rating_userIdTouser: Prisma.$ratingPayload<ExtArgs>[]
      ridestatus: Prisma.$ridestatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      fullName: string
      gender: string | null
      address: string | null
      phone: string
      email: string | null
      password: string
      role: string
      dob: Date
      cic: string
      avatar: string
      createdAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const userWithUuidOnly = await prisma.user.findMany({ select: { uuid: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    call_call_userCallIdTouser<T extends user$call_call_userCallIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$call_call_userCallIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'findMany'> | Null>;

    call_call_userAnswerIdTouser<T extends user$call_call_userAnswerIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$call_call_userAnswerIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$callPayload<ExtArgs>, T, 'findMany'> | Null>;

    callcenteragent<T extends user$callcenteragentArgs<ExtArgs> = {}>(args?: Subset<T, user$callcenteragentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$callcenteragentPayload<ExtArgs>, T, 'findMany'> | Null>;

    customer<T extends user$customerArgs<ExtArgs> = {}>(args?: Subset<T, user$customerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, 'findMany'> | Null>;

    driver<T extends user$driverArgs<ExtArgs> = {}>(args?: Subset<T, user$driverArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$driverPayload<ExtArgs>, T, 'findMany'> | Null>;

    drivershift<T extends user$drivershiftArgs<ExtArgs> = {}>(args?: Subset<T, user$drivershiftArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drivershiftPayload<ExtArgs>, T, 'findMany'> | Null>;

    message_message_senderIdTouser<T extends user$message_message_senderIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$message_message_senderIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'findMany'> | Null>;

    message_message_receiverIdTouser<T extends user$message_message_receiverIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$message_message_receiverIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, 'findMany'> | Null>;

    rating_rating_driverIdTouser<T extends user$rating_rating_driverIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$rating_rating_driverIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'findMany'> | Null>;

    rating_rating_userIdTouser<T extends user$rating_rating_userIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$rating_rating_userIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, 'findMany'> | Null>;

    ridestatus<T extends user$ridestatusArgs<ExtArgs> = {}>(args?: Subset<T, user$ridestatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ridestatusPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly uuid: FieldRef<"user", 'String'>
    readonly fullName: FieldRef<"user", 'String'>
    readonly gender: FieldRef<"user", 'String'>
    readonly address: FieldRef<"user", 'String'>
    readonly phone: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'String'>
    readonly dob: FieldRef<"user", 'DateTime'>
    readonly cic: FieldRef<"user", 'String'>
    readonly avatar: FieldRef<"user", 'String'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.call_call_userCallIdTouser
   */
  export type user$call_call_userCallIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    where?: callWhereInput
    orderBy?: callOrderByWithRelationInput | callOrderByWithRelationInput[]
    cursor?: callWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }


  /**
   * user.call_call_userAnswerIdTouser
   */
  export type user$call_call_userAnswerIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call
     */
    select?: callSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callInclude<ExtArgs> | null
    where?: callWhereInput
    orderBy?: callOrderByWithRelationInput | callOrderByWithRelationInput[]
    cursor?: callWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }


  /**
   * user.callcenteragent
   */
  export type user$callcenteragentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the callcenteragent
     */
    select?: callcenteragentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: callcenteragentInclude<ExtArgs> | null
    where?: callcenteragentWhereInput
    orderBy?: callcenteragentOrderByWithRelationInput | callcenteragentOrderByWithRelationInput[]
    cursor?: callcenteragentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallcenteragentScalarFieldEnum | CallcenteragentScalarFieldEnum[]
  }


  /**
   * user.customer
   */
  export type user$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    cursor?: customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * user.driver
   */
  export type user$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude<ExtArgs> | null
    where?: driverWhereInput
    orderBy?: driverOrderByWithRelationInput | driverOrderByWithRelationInput[]
    cursor?: driverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }


  /**
   * user.drivershift
   */
  export type user$drivershiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drivershift
     */
    select?: drivershiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drivershiftInclude<ExtArgs> | null
    where?: drivershiftWhereInput
    orderBy?: drivershiftOrderByWithRelationInput | drivershiftOrderByWithRelationInput[]
    cursor?: drivershiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DrivershiftScalarFieldEnum | DrivershiftScalarFieldEnum[]
  }


  /**
   * user.message_message_senderIdTouser
   */
  export type user$message_message_senderIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * user.message_message_receiverIdTouser
   */
  export type user$message_message_receiverIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * user.rating_rating_driverIdTouser
   */
  export type user$rating_rating_driverIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    where?: ratingWhereInput
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    cursor?: ratingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * user.rating_rating_userIdTouser
   */
  export type user$rating_rating_userIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ratingInclude<ExtArgs> | null
    where?: ratingWhereInput
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    cursor?: ratingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * user.ridestatus
   */
  export type user$ridestatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ridestatus
     */
    select?: ridestatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ridestatusInclude<ExtArgs> | null
    where?: ridestatusWhereInput
    orderBy?: ridestatusOrderByWithRelationInput | ridestatusOrderByWithRelationInput[]
    cursor?: ridestatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RidestatusScalarFieldEnum | RidestatusScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CallScalarFieldEnum: {
    uuid: 'uuid',
    userCallId: 'userCallId',
    userAnswerId: 'userAnswerId',
    beginCallingTime: 'beginCallingTime',
    endCallingTime: 'endCallingTime',
    callingStatus: 'callingStatus'
  };

  export type CallScalarFieldEnum = (typeof CallScalarFieldEnum)[keyof typeof CallScalarFieldEnum]


  export const CallcenteragentScalarFieldEnum: {
    uuid: 'uuid',
    userId: 'userId',
    state: 'state'
  };

  export type CallcenteragentScalarFieldEnum = (typeof CallcenteragentScalarFieldEnum)[keyof typeof CallcenteragentScalarFieldEnum]


  export const CarScalarFieldEnum: {
    uuid: 'uuid',
    modelName: 'modelName',
    modelDescription: 'modelDescription',
    manufactureYear: 'manufactureYear',
    seat: 'seat',
    color: 'color',
    carImage: 'carImage',
    licensePlate: 'licensePlate'
  };

  export type CarScalarFieldEnum = (typeof CarScalarFieldEnum)[keyof typeof CarScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    uuid: 'uuid',
    userId: 'userId',
    state: 'state'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    uuid: 'uuid',
    userId: 'userId',
    drivingLicenceNumber: 'drivingLicenceNumber',
    expiryDate: 'expiryDate',
    state: 'state'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const DrivershiftScalarFieldEnum: {
    uuid: 'uuid',
    driverId: 'driverId',
    carId: 'carId',
    shiftStartTime: 'shiftStartTime',
    shiftEndTime: 'shiftEndTime',
    createdAt: 'createdAt'
  };

  export type DrivershiftScalarFieldEnum = (typeof DrivershiftScalarFieldEnum)[keyof typeof DrivershiftScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    uuid: 'uuid',
    rideId: 'rideId',
    senderId: 'senderId',
    receiverId: 'receiverId',
    sendingTime: 'sendingTime',
    message: 'message'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    uuid: 'uuid',
    rideId: 'rideId',
    driverId: 'driverId',
    userId: 'userId',
    ratingComment: 'ratingComment',
    ratingTag: 'ratingTag',
    ratingValue: 'ratingValue',
    ratingTime: 'ratingTime'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const RideScalarFieldEnum: {
    uuid: 'uuid',
    fullName: 'fullName',
    gender: 'gender',
    phone: 'phone',
    seat: 'seat',
    rideStartTime: 'rideStartTime',
    rideEndTime: 'rideEndTime',
    startingPoint: 'startingPoint',
    destinationPoint: 'destinationPoint',
    distance: 'distance',
    price: 'price',
    note: 'note'
  };

  export type RideScalarFieldEnum = (typeof RideScalarFieldEnum)[keyof typeof RideScalarFieldEnum]


  export const RidestatusScalarFieldEnum: {
    uuid: 'uuid',
    rideId: 'rideId',
    driverId: 'driverId',
    driverShiftId: 'driverShiftId',
    state: 'state',
    stateTime: 'stateTime',
    stateDetail: 'stateDetail'
  };

  export type RidestatusScalarFieldEnum = (typeof RidestatusScalarFieldEnum)[keyof typeof RidestatusScalarFieldEnum]


  export const UserScalarFieldEnum: {
    uuid: 'uuid',
    fullName: 'fullName',
    gender: 'gender',
    address: 'address',
    phone: 'phone',
    email: 'email',
    password: 'password',
    role: 'role',
    dob: 'dob',
    cic: 'cic',
    avatar: 'avatar',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type callWhereInput = {
    AND?: callWhereInput | callWhereInput[]
    OR?: callWhereInput[]
    NOT?: callWhereInput | callWhereInput[]
    uuid?: StringFilter<"call"> | string
    userCallId?: StringFilter<"call"> | string
    userAnswerId?: StringFilter<"call"> | string
    beginCallingTime?: DateTimeFilter<"call"> | Date | string
    endCallingTime?: DateTimeNullableFilter<"call"> | Date | string | null
    callingStatus?: StringFilter<"call"> | string
    user_call_userCallIdTouser?: XOR<UserRelationFilter, userWhereInput>
    user_call_userAnswerIdTouser?: XOR<UserRelationFilter, userWhereInput>
  }

  export type callOrderByWithRelationInput = {
    uuid?: SortOrder
    userCallId?: SortOrder
    userAnswerId?: SortOrder
    beginCallingTime?: SortOrder
    endCallingTime?: SortOrderInput | SortOrder
    callingStatus?: SortOrder
    user_call_userCallIdTouser?: userOrderByWithRelationInput
    user_call_userAnswerIdTouser?: userOrderByWithRelationInput
  }

  export type callWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: callWhereInput | callWhereInput[]
    OR?: callWhereInput[]
    NOT?: callWhereInput | callWhereInput[]
    userCallId?: StringFilter<"call"> | string
    userAnswerId?: StringFilter<"call"> | string
    beginCallingTime?: DateTimeFilter<"call"> | Date | string
    endCallingTime?: DateTimeNullableFilter<"call"> | Date | string | null
    callingStatus?: StringFilter<"call"> | string
    user_call_userCallIdTouser?: XOR<UserRelationFilter, userWhereInput>
    user_call_userAnswerIdTouser?: XOR<UserRelationFilter, userWhereInput>
  }, "uuid">

  export type callOrderByWithAggregationInput = {
    uuid?: SortOrder
    userCallId?: SortOrder
    userAnswerId?: SortOrder
    beginCallingTime?: SortOrder
    endCallingTime?: SortOrderInput | SortOrder
    callingStatus?: SortOrder
    _count?: callCountOrderByAggregateInput
    _max?: callMaxOrderByAggregateInput
    _min?: callMinOrderByAggregateInput
  }

  export type callScalarWhereWithAggregatesInput = {
    AND?: callScalarWhereWithAggregatesInput | callScalarWhereWithAggregatesInput[]
    OR?: callScalarWhereWithAggregatesInput[]
    NOT?: callScalarWhereWithAggregatesInput | callScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"call"> | string
    userCallId?: StringWithAggregatesFilter<"call"> | string
    userAnswerId?: StringWithAggregatesFilter<"call"> | string
    beginCallingTime?: DateTimeWithAggregatesFilter<"call"> | Date | string
    endCallingTime?: DateTimeNullableWithAggregatesFilter<"call"> | Date | string | null
    callingStatus?: StringWithAggregatesFilter<"call"> | string
  }

  export type callcenteragentWhereInput = {
    AND?: callcenteragentWhereInput | callcenteragentWhereInput[]
    OR?: callcenteragentWhereInput[]
    NOT?: callcenteragentWhereInput | callcenteragentWhereInput[]
    uuid?: StringFilter<"callcenteragent"> | string
    userId?: StringFilter<"callcenteragent"> | string
    state?: StringFilter<"callcenteragent"> | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type callcenteragentOrderByWithRelationInput = {
    uuid?: SortOrder
    userId?: SortOrder
    state?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type callcenteragentWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: callcenteragentWhereInput | callcenteragentWhereInput[]
    OR?: callcenteragentWhereInput[]
    NOT?: callcenteragentWhereInput | callcenteragentWhereInput[]
    userId?: StringFilter<"callcenteragent"> | string
    state?: StringFilter<"callcenteragent"> | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "uuid">

  export type callcenteragentOrderByWithAggregationInput = {
    uuid?: SortOrder
    userId?: SortOrder
    state?: SortOrder
    _count?: callcenteragentCountOrderByAggregateInput
    _max?: callcenteragentMaxOrderByAggregateInput
    _min?: callcenteragentMinOrderByAggregateInput
  }

  export type callcenteragentScalarWhereWithAggregatesInput = {
    AND?: callcenteragentScalarWhereWithAggregatesInput | callcenteragentScalarWhereWithAggregatesInput[]
    OR?: callcenteragentScalarWhereWithAggregatesInput[]
    NOT?: callcenteragentScalarWhereWithAggregatesInput | callcenteragentScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"callcenteragent"> | string
    userId?: StringWithAggregatesFilter<"callcenteragent"> | string
    state?: StringWithAggregatesFilter<"callcenteragent"> | string
  }

  export type carWhereInput = {
    AND?: carWhereInput | carWhereInput[]
    OR?: carWhereInput[]
    NOT?: carWhereInput | carWhereInput[]
    uuid?: StringFilter<"car"> | string
    modelName?: StringFilter<"car"> | string
    modelDescription?: StringNullableFilter<"car"> | string | null
    manufactureYear?: DateTimeFilter<"car"> | Date | string
    seat?: IntFilter<"car"> | number
    color?: StringNullableFilter<"car"> | string | null
    carImage?: StringFilter<"car"> | string
    licensePlate?: StringFilter<"car"> | string
    drivershift?: DrivershiftListRelationFilter
  }

  export type carOrderByWithRelationInput = {
    uuid?: SortOrder
    modelName?: SortOrder
    modelDescription?: SortOrderInput | SortOrder
    manufactureYear?: SortOrder
    seat?: SortOrder
    color?: SortOrderInput | SortOrder
    carImage?: SortOrder
    licensePlate?: SortOrder
    drivershift?: drivershiftOrderByRelationAggregateInput
  }

  export type carWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    licensePlate?: string
    AND?: carWhereInput | carWhereInput[]
    OR?: carWhereInput[]
    NOT?: carWhereInput | carWhereInput[]
    modelName?: StringFilter<"car"> | string
    modelDescription?: StringNullableFilter<"car"> | string | null
    manufactureYear?: DateTimeFilter<"car"> | Date | string
    seat?: IntFilter<"car"> | number
    color?: StringNullableFilter<"car"> | string | null
    carImage?: StringFilter<"car"> | string
    drivershift?: DrivershiftListRelationFilter
  }, "uuid" | "licensePlate">

  export type carOrderByWithAggregationInput = {
    uuid?: SortOrder
    modelName?: SortOrder
    modelDescription?: SortOrderInput | SortOrder
    manufactureYear?: SortOrder
    seat?: SortOrder
    color?: SortOrderInput | SortOrder
    carImage?: SortOrder
    licensePlate?: SortOrder
    _count?: carCountOrderByAggregateInput
    _avg?: carAvgOrderByAggregateInput
    _max?: carMaxOrderByAggregateInput
    _min?: carMinOrderByAggregateInput
    _sum?: carSumOrderByAggregateInput
  }

  export type carScalarWhereWithAggregatesInput = {
    AND?: carScalarWhereWithAggregatesInput | carScalarWhereWithAggregatesInput[]
    OR?: carScalarWhereWithAggregatesInput[]
    NOT?: carScalarWhereWithAggregatesInput | carScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"car"> | string
    modelName?: StringWithAggregatesFilter<"car"> | string
    modelDescription?: StringNullableWithAggregatesFilter<"car"> | string | null
    manufactureYear?: DateTimeWithAggregatesFilter<"car"> | Date | string
    seat?: IntWithAggregatesFilter<"car"> | number
    color?: StringNullableWithAggregatesFilter<"car"> | string | null
    carImage?: StringWithAggregatesFilter<"car"> | string
    licensePlate?: StringWithAggregatesFilter<"car"> | string
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    uuid?: StringFilter<"customer"> | string
    userId?: StringNullableFilter<"customer"> | string | null
    state?: StringFilter<"customer"> | string
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type customerOrderByWithRelationInput = {
    uuid?: SortOrder
    userId?: SortOrderInput | SortOrder
    state?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    userId?: StringNullableFilter<"customer"> | string | null
    state?: StringFilter<"customer"> | string
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "uuid">

  export type customerOrderByWithAggregationInput = {
    uuid?: SortOrder
    userId?: SortOrderInput | SortOrder
    state?: SortOrder
    _count?: customerCountOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"customer"> | string
    userId?: StringNullableWithAggregatesFilter<"customer"> | string | null
    state?: StringWithAggregatesFilter<"customer"> | string
  }

  export type driverWhereInput = {
    AND?: driverWhereInput | driverWhereInput[]
    OR?: driverWhereInput[]
    NOT?: driverWhereInput | driverWhereInput[]
    uuid?: StringFilter<"driver"> | string
    userId?: StringFilter<"driver"> | string
    drivingLicenceNumber?: StringFilter<"driver"> | string
    expiryDate?: DateTimeFilter<"driver"> | Date | string
    state?: StringFilter<"driver"> | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type driverOrderByWithRelationInput = {
    uuid?: SortOrder
    userId?: SortOrder
    drivingLicenceNumber?: SortOrder
    expiryDate?: SortOrder
    state?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type driverWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: driverWhereInput | driverWhereInput[]
    OR?: driverWhereInput[]
    NOT?: driverWhereInput | driverWhereInput[]
    userId?: StringFilter<"driver"> | string
    drivingLicenceNumber?: StringFilter<"driver"> | string
    expiryDate?: DateTimeFilter<"driver"> | Date | string
    state?: StringFilter<"driver"> | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "uuid">

  export type driverOrderByWithAggregationInput = {
    uuid?: SortOrder
    userId?: SortOrder
    drivingLicenceNumber?: SortOrder
    expiryDate?: SortOrder
    state?: SortOrder
    _count?: driverCountOrderByAggregateInput
    _max?: driverMaxOrderByAggregateInput
    _min?: driverMinOrderByAggregateInput
  }

  export type driverScalarWhereWithAggregatesInput = {
    AND?: driverScalarWhereWithAggregatesInput | driverScalarWhereWithAggregatesInput[]
    OR?: driverScalarWhereWithAggregatesInput[]
    NOT?: driverScalarWhereWithAggregatesInput | driverScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"driver"> | string
    userId?: StringWithAggregatesFilter<"driver"> | string
    drivingLicenceNumber?: StringWithAggregatesFilter<"driver"> | string
    expiryDate?: DateTimeWithAggregatesFilter<"driver"> | Date | string
    state?: StringWithAggregatesFilter<"driver"> | string
  }

  export type drivershiftWhereInput = {
    AND?: drivershiftWhereInput | drivershiftWhereInput[]
    OR?: drivershiftWhereInput[]
    NOT?: drivershiftWhereInput | drivershiftWhereInput[]
    uuid?: StringFilter<"drivershift"> | string
    driverId?: StringFilter<"drivershift"> | string
    carId?: StringFilter<"drivershift"> | string
    shiftStartTime?: DateTimeFilter<"drivershift"> | Date | string
    shiftEndTime?: DateTimeFilter<"drivershift"> | Date | string
    createdAt?: DateTimeNullableFilter<"drivershift"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    car?: XOR<CarRelationFilter, carWhereInput>
    ridestatus?: RidestatusListRelationFilter
  }

  export type drivershiftOrderByWithRelationInput = {
    uuid?: SortOrder
    driverId?: SortOrder
    carId?: SortOrder
    shiftStartTime?: SortOrder
    shiftEndTime?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    car?: carOrderByWithRelationInput
    ridestatus?: ridestatusOrderByRelationAggregateInput
  }

  export type drivershiftWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: drivershiftWhereInput | drivershiftWhereInput[]
    OR?: drivershiftWhereInput[]
    NOT?: drivershiftWhereInput | drivershiftWhereInput[]
    driverId?: StringFilter<"drivershift"> | string
    carId?: StringFilter<"drivershift"> | string
    shiftStartTime?: DateTimeFilter<"drivershift"> | Date | string
    shiftEndTime?: DateTimeFilter<"drivershift"> | Date | string
    createdAt?: DateTimeNullableFilter<"drivershift"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    car?: XOR<CarRelationFilter, carWhereInput>
    ridestatus?: RidestatusListRelationFilter
  }, "uuid">

  export type drivershiftOrderByWithAggregationInput = {
    uuid?: SortOrder
    driverId?: SortOrder
    carId?: SortOrder
    shiftStartTime?: SortOrder
    shiftEndTime?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: drivershiftCountOrderByAggregateInput
    _max?: drivershiftMaxOrderByAggregateInput
    _min?: drivershiftMinOrderByAggregateInput
  }

  export type drivershiftScalarWhereWithAggregatesInput = {
    AND?: drivershiftScalarWhereWithAggregatesInput | drivershiftScalarWhereWithAggregatesInput[]
    OR?: drivershiftScalarWhereWithAggregatesInput[]
    NOT?: drivershiftScalarWhereWithAggregatesInput | drivershiftScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"drivershift"> | string
    driverId?: StringWithAggregatesFilter<"drivershift"> | string
    carId?: StringWithAggregatesFilter<"drivershift"> | string
    shiftStartTime?: DateTimeWithAggregatesFilter<"drivershift"> | Date | string
    shiftEndTime?: DateTimeWithAggregatesFilter<"drivershift"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"drivershift"> | Date | string | null
  }

  export type messageWhereInput = {
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    uuid?: StringFilter<"message"> | string
    rideId?: StringFilter<"message"> | string
    senderId?: StringFilter<"message"> | string
    receiverId?: StringFilter<"message"> | string
    sendingTime?: DateTimeFilter<"message"> | Date | string
    message?: StringFilter<"message"> | string
    ride?: XOR<RideRelationFilter, rideWhereInput>
    user_message_senderIdTouser?: XOR<UserRelationFilter, userWhereInput>
    user_message_receiverIdTouser?: XOR<UserRelationFilter, userWhereInput>
  }

  export type messageOrderByWithRelationInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    sendingTime?: SortOrder
    message?: SortOrder
    ride?: rideOrderByWithRelationInput
    user_message_senderIdTouser?: userOrderByWithRelationInput
    user_message_receiverIdTouser?: userOrderByWithRelationInput
  }

  export type messageWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    rideId?: StringFilter<"message"> | string
    senderId?: StringFilter<"message"> | string
    receiverId?: StringFilter<"message"> | string
    sendingTime?: DateTimeFilter<"message"> | Date | string
    message?: StringFilter<"message"> | string
    ride?: XOR<RideRelationFilter, rideWhereInput>
    user_message_senderIdTouser?: XOR<UserRelationFilter, userWhereInput>
    user_message_receiverIdTouser?: XOR<UserRelationFilter, userWhereInput>
  }, "uuid">

  export type messageOrderByWithAggregationInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    sendingTime?: SortOrder
    message?: SortOrder
    _count?: messageCountOrderByAggregateInput
    _max?: messageMaxOrderByAggregateInput
    _min?: messageMinOrderByAggregateInput
  }

  export type messageScalarWhereWithAggregatesInput = {
    AND?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    OR?: messageScalarWhereWithAggregatesInput[]
    NOT?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"message"> | string
    rideId?: StringWithAggregatesFilter<"message"> | string
    senderId?: StringWithAggregatesFilter<"message"> | string
    receiverId?: StringWithAggregatesFilter<"message"> | string
    sendingTime?: DateTimeWithAggregatesFilter<"message"> | Date | string
    message?: StringWithAggregatesFilter<"message"> | string
  }

  export type ratingWhereInput = {
    AND?: ratingWhereInput | ratingWhereInput[]
    OR?: ratingWhereInput[]
    NOT?: ratingWhereInput | ratingWhereInput[]
    uuid?: StringFilter<"rating"> | string
    rideId?: StringFilter<"rating"> | string
    driverId?: StringFilter<"rating"> | string
    userId?: StringFilter<"rating"> | string
    ratingComment?: StringNullableFilter<"rating"> | string | null
    ratingTag?: StringNullableFilter<"rating"> | string | null
    ratingValue?: IntFilter<"rating"> | number
    ratingTime?: DateTimeFilter<"rating"> | Date | string
    ride?: XOR<RideRelationFilter, rideWhereInput>
    user_rating_driverIdTouser?: XOR<UserRelationFilter, userWhereInput>
    user_rating_userIdTouser?: XOR<UserRelationFilter, userWhereInput>
  }

  export type ratingOrderByWithRelationInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrder
    userId?: SortOrder
    ratingComment?: SortOrderInput | SortOrder
    ratingTag?: SortOrderInput | SortOrder
    ratingValue?: SortOrder
    ratingTime?: SortOrder
    ride?: rideOrderByWithRelationInput
    user_rating_driverIdTouser?: userOrderByWithRelationInput
    user_rating_userIdTouser?: userOrderByWithRelationInput
  }

  export type ratingWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: ratingWhereInput | ratingWhereInput[]
    OR?: ratingWhereInput[]
    NOT?: ratingWhereInput | ratingWhereInput[]
    rideId?: StringFilter<"rating"> | string
    driverId?: StringFilter<"rating"> | string
    userId?: StringFilter<"rating"> | string
    ratingComment?: StringNullableFilter<"rating"> | string | null
    ratingTag?: StringNullableFilter<"rating"> | string | null
    ratingValue?: IntFilter<"rating"> | number
    ratingTime?: DateTimeFilter<"rating"> | Date | string
    ride?: XOR<RideRelationFilter, rideWhereInput>
    user_rating_driverIdTouser?: XOR<UserRelationFilter, userWhereInput>
    user_rating_userIdTouser?: XOR<UserRelationFilter, userWhereInput>
  }, "uuid">

  export type ratingOrderByWithAggregationInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrder
    userId?: SortOrder
    ratingComment?: SortOrderInput | SortOrder
    ratingTag?: SortOrderInput | SortOrder
    ratingValue?: SortOrder
    ratingTime?: SortOrder
    _count?: ratingCountOrderByAggregateInput
    _avg?: ratingAvgOrderByAggregateInput
    _max?: ratingMaxOrderByAggregateInput
    _min?: ratingMinOrderByAggregateInput
    _sum?: ratingSumOrderByAggregateInput
  }

  export type ratingScalarWhereWithAggregatesInput = {
    AND?: ratingScalarWhereWithAggregatesInput | ratingScalarWhereWithAggregatesInput[]
    OR?: ratingScalarWhereWithAggregatesInput[]
    NOT?: ratingScalarWhereWithAggregatesInput | ratingScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"rating"> | string
    rideId?: StringWithAggregatesFilter<"rating"> | string
    driverId?: StringWithAggregatesFilter<"rating"> | string
    userId?: StringWithAggregatesFilter<"rating"> | string
    ratingComment?: StringNullableWithAggregatesFilter<"rating"> | string | null
    ratingTag?: StringNullableWithAggregatesFilter<"rating"> | string | null
    ratingValue?: IntWithAggregatesFilter<"rating"> | number
    ratingTime?: DateTimeWithAggregatesFilter<"rating"> | Date | string
  }

  export type rideWhereInput = {
    AND?: rideWhereInput | rideWhereInput[]
    OR?: rideWhereInput[]
    NOT?: rideWhereInput | rideWhereInput[]
    uuid?: StringFilter<"ride"> | string
    fullName?: StringFilter<"ride"> | string
    gender?: StringNullableFilter<"ride"> | string | null
    phone?: StringFilter<"ride"> | string
    seat?: IntFilter<"ride"> | number
    rideStartTime?: DateTimeFilter<"ride"> | Date | string
    rideEndTime?: DateTimeNullableFilter<"ride"> | Date | string | null
    startingPoint?: StringFilter<"ride"> | string
    destinationPoint?: StringFilter<"ride"> | string
    distance?: FloatNullableFilter<"ride"> | number | null
    price?: IntNullableFilter<"ride"> | number | null
    note?: StringNullableFilter<"ride"> | string | null
    message?: MessageListRelationFilter
    rating?: RatingListRelationFilter
    ridestatus?: RidestatusListRelationFilter
  }

  export type rideOrderByWithRelationInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrder
    seat?: SortOrder
    rideStartTime?: SortOrder
    rideEndTime?: SortOrderInput | SortOrder
    startingPoint?: SortOrder
    destinationPoint?: SortOrder
    distance?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    message?: messageOrderByRelationAggregateInput
    rating?: ratingOrderByRelationAggregateInput
    ridestatus?: ridestatusOrderByRelationAggregateInput
  }

  export type rideWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: rideWhereInput | rideWhereInput[]
    OR?: rideWhereInput[]
    NOT?: rideWhereInput | rideWhereInput[]
    fullName?: StringFilter<"ride"> | string
    gender?: StringNullableFilter<"ride"> | string | null
    phone?: StringFilter<"ride"> | string
    seat?: IntFilter<"ride"> | number
    rideStartTime?: DateTimeFilter<"ride"> | Date | string
    rideEndTime?: DateTimeNullableFilter<"ride"> | Date | string | null
    startingPoint?: StringFilter<"ride"> | string
    destinationPoint?: StringFilter<"ride"> | string
    distance?: FloatNullableFilter<"ride"> | number | null
    price?: IntNullableFilter<"ride"> | number | null
    note?: StringNullableFilter<"ride"> | string | null
    message?: MessageListRelationFilter
    rating?: RatingListRelationFilter
    ridestatus?: RidestatusListRelationFilter
  }, "uuid">

  export type rideOrderByWithAggregationInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrder
    seat?: SortOrder
    rideStartTime?: SortOrder
    rideEndTime?: SortOrderInput | SortOrder
    startingPoint?: SortOrder
    destinationPoint?: SortOrder
    distance?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    _count?: rideCountOrderByAggregateInput
    _avg?: rideAvgOrderByAggregateInput
    _max?: rideMaxOrderByAggregateInput
    _min?: rideMinOrderByAggregateInput
    _sum?: rideSumOrderByAggregateInput
  }

  export type rideScalarWhereWithAggregatesInput = {
    AND?: rideScalarWhereWithAggregatesInput | rideScalarWhereWithAggregatesInput[]
    OR?: rideScalarWhereWithAggregatesInput[]
    NOT?: rideScalarWhereWithAggregatesInput | rideScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"ride"> | string
    fullName?: StringWithAggregatesFilter<"ride"> | string
    gender?: StringNullableWithAggregatesFilter<"ride"> | string | null
    phone?: StringWithAggregatesFilter<"ride"> | string
    seat?: IntWithAggregatesFilter<"ride"> | number
    rideStartTime?: DateTimeWithAggregatesFilter<"ride"> | Date | string
    rideEndTime?: DateTimeNullableWithAggregatesFilter<"ride"> | Date | string | null
    startingPoint?: StringWithAggregatesFilter<"ride"> | string
    destinationPoint?: StringWithAggregatesFilter<"ride"> | string
    distance?: FloatNullableWithAggregatesFilter<"ride"> | number | null
    price?: IntNullableWithAggregatesFilter<"ride"> | number | null
    note?: StringNullableWithAggregatesFilter<"ride"> | string | null
  }

  export type ridestatusWhereInput = {
    AND?: ridestatusWhereInput | ridestatusWhereInput[]
    OR?: ridestatusWhereInput[]
    NOT?: ridestatusWhereInput | ridestatusWhereInput[]
    uuid?: StringFilter<"ridestatus"> | string
    rideId?: StringFilter<"ridestatus"> | string
    driverId?: StringNullableFilter<"ridestatus"> | string | null
    driverShiftId?: StringNullableFilter<"ridestatus"> | string | null
    state?: StringFilter<"ridestatus"> | string
    stateTime?: DateTimeFilter<"ridestatus"> | Date | string
    stateDetail?: StringNullableFilter<"ridestatus"> | string | null
    ride?: XOR<RideRelationFilter, rideWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    drivershift?: XOR<DrivershiftNullableRelationFilter, drivershiftWhereInput> | null
  }

  export type ridestatusOrderByWithRelationInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrderInput | SortOrder
    driverShiftId?: SortOrderInput | SortOrder
    state?: SortOrder
    stateTime?: SortOrder
    stateDetail?: SortOrderInput | SortOrder
    ride?: rideOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    drivershift?: drivershiftOrderByWithRelationInput
  }

  export type ridestatusWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: ridestatusWhereInput | ridestatusWhereInput[]
    OR?: ridestatusWhereInput[]
    NOT?: ridestatusWhereInput | ridestatusWhereInput[]
    rideId?: StringFilter<"ridestatus"> | string
    driverId?: StringNullableFilter<"ridestatus"> | string | null
    driverShiftId?: StringNullableFilter<"ridestatus"> | string | null
    state?: StringFilter<"ridestatus"> | string
    stateTime?: DateTimeFilter<"ridestatus"> | Date | string
    stateDetail?: StringNullableFilter<"ridestatus"> | string | null
    ride?: XOR<RideRelationFilter, rideWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    drivershift?: XOR<DrivershiftNullableRelationFilter, drivershiftWhereInput> | null
  }, "uuid">

  export type ridestatusOrderByWithAggregationInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrderInput | SortOrder
    driverShiftId?: SortOrderInput | SortOrder
    state?: SortOrder
    stateTime?: SortOrder
    stateDetail?: SortOrderInput | SortOrder
    _count?: ridestatusCountOrderByAggregateInput
    _max?: ridestatusMaxOrderByAggregateInput
    _min?: ridestatusMinOrderByAggregateInput
  }

  export type ridestatusScalarWhereWithAggregatesInput = {
    AND?: ridestatusScalarWhereWithAggregatesInput | ridestatusScalarWhereWithAggregatesInput[]
    OR?: ridestatusScalarWhereWithAggregatesInput[]
    NOT?: ridestatusScalarWhereWithAggregatesInput | ridestatusScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"ridestatus"> | string
    rideId?: StringWithAggregatesFilter<"ridestatus"> | string
    driverId?: StringNullableWithAggregatesFilter<"ridestatus"> | string | null
    driverShiftId?: StringNullableWithAggregatesFilter<"ridestatus"> | string | null
    state?: StringWithAggregatesFilter<"ridestatus"> | string
    stateTime?: DateTimeWithAggregatesFilter<"ridestatus"> | Date | string
    stateDetail?: StringNullableWithAggregatesFilter<"ridestatus"> | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    uuid?: StringFilter<"user"> | string
    fullName?: StringFilter<"user"> | string
    gender?: StringNullableFilter<"user"> | string | null
    address?: StringNullableFilter<"user"> | string | null
    phone?: StringFilter<"user"> | string
    email?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    role?: StringFilter<"user"> | string
    dob?: DateTimeFilter<"user"> | Date | string
    cic?: StringFilter<"user"> | string
    avatar?: StringFilter<"user"> | string
    createdAt?: DateTimeNullableFilter<"user"> | Date | string | null
    call_call_userCallIdTouser?: CallListRelationFilter
    call_call_userAnswerIdTouser?: CallListRelationFilter
    callcenteragent?: CallcenteragentListRelationFilter
    customer?: CustomerListRelationFilter
    driver?: DriverListRelationFilter
    drivershift?: DrivershiftListRelationFilter
    message_message_senderIdTouser?: MessageListRelationFilter
    message_message_receiverIdTouser?: MessageListRelationFilter
    rating_rating_driverIdTouser?: RatingListRelationFilter
    rating_rating_userIdTouser?: RatingListRelationFilter
    ridestatus?: RidestatusListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    dob?: SortOrder
    cic?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    call_call_userCallIdTouser?: callOrderByRelationAggregateInput
    call_call_userAnswerIdTouser?: callOrderByRelationAggregateInput
    callcenteragent?: callcenteragentOrderByRelationAggregateInput
    customer?: customerOrderByRelationAggregateInput
    driver?: driverOrderByRelationAggregateInput
    drivershift?: drivershiftOrderByRelationAggregateInput
    message_message_senderIdTouser?: messageOrderByRelationAggregateInput
    message_message_receiverIdTouser?: messageOrderByRelationAggregateInput
    rating_rating_driverIdTouser?: ratingOrderByRelationAggregateInput
    rating_rating_userIdTouser?: ratingOrderByRelationAggregateInput
    ridestatus?: ridestatusOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    phone?: string
    email?: string
    cic?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    fullName?: StringFilter<"user"> | string
    gender?: StringNullableFilter<"user"> | string | null
    address?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    role?: StringFilter<"user"> | string
    dob?: DateTimeFilter<"user"> | Date | string
    avatar?: StringFilter<"user"> | string
    createdAt?: DateTimeNullableFilter<"user"> | Date | string | null
    call_call_userCallIdTouser?: CallListRelationFilter
    call_call_userAnswerIdTouser?: CallListRelationFilter
    callcenteragent?: CallcenteragentListRelationFilter
    customer?: CustomerListRelationFilter
    driver?: DriverListRelationFilter
    drivershift?: DrivershiftListRelationFilter
    message_message_senderIdTouser?: MessageListRelationFilter
    message_message_receiverIdTouser?: MessageListRelationFilter
    rating_rating_driverIdTouser?: RatingListRelationFilter
    rating_rating_userIdTouser?: RatingListRelationFilter
    ridestatus?: RidestatusListRelationFilter
  }, "uuid" | "phone" | "email" | "cic">

  export type userOrderByWithAggregationInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    dob?: SortOrder
    cic?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"user"> | string
    fullName?: StringWithAggregatesFilter<"user"> | string
    gender?: StringNullableWithAggregatesFilter<"user"> | string | null
    address?: StringNullableWithAggregatesFilter<"user"> | string | null
    phone?: StringWithAggregatesFilter<"user"> | string
    email?: StringNullableWithAggregatesFilter<"user"> | string | null
    password?: StringWithAggregatesFilter<"user"> | string
    role?: StringWithAggregatesFilter<"user"> | string
    dob?: DateTimeWithAggregatesFilter<"user"> | Date | string
    cic?: StringWithAggregatesFilter<"user"> | string
    avatar?: StringWithAggregatesFilter<"user"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
  }

  export type callCreateInput = {
    uuid?: string
    beginCallingTime?: Date | string
    endCallingTime?: Date | string | null
    callingStatus: string
    user_call_userCallIdTouser: userCreateNestedOneWithoutCall_call_userCallIdTouserInput
    user_call_userAnswerIdTouser: userCreateNestedOneWithoutCall_call_userAnswerIdTouserInput
  }

  export type callUncheckedCreateInput = {
    uuid?: string
    userCallId: string
    userAnswerId: string
    beginCallingTime?: Date | string
    endCallingTime?: Date | string | null
    callingStatus: string
  }

  export type callUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
    user_call_userCallIdTouser?: userUpdateOneRequiredWithoutCall_call_userCallIdTouserNestedInput
    user_call_userAnswerIdTouser?: userUpdateOneRequiredWithoutCall_call_userAnswerIdTouserNestedInput
  }

  export type callUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userCallId?: StringFieldUpdateOperationsInput | string
    userAnswerId?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type callCreateManyInput = {
    uuid?: string
    userCallId: string
    userAnswerId: string
    beginCallingTime?: Date | string
    endCallingTime?: Date | string | null
    callingStatus: string
  }

  export type callUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type callUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userCallId?: StringFieldUpdateOperationsInput | string
    userAnswerId?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type callcenteragentCreateInput = {
    uuid?: string
    state?: string
    user: userCreateNestedOneWithoutCallcenteragentInput
  }

  export type callcenteragentUncheckedCreateInput = {
    uuid?: string
    userId: string
    state?: string
  }

  export type callcenteragentUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutCallcenteragentNestedInput
  }

  export type callcenteragentUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type callcenteragentCreateManyInput = {
    uuid?: string
    userId: string
    state?: string
  }

  export type callcenteragentUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type callcenteragentUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type carCreateInput = {
    uuid?: string
    modelName: string
    modelDescription?: string | null
    manufactureYear: Date | string
    seat?: number
    color?: string | null
    carImage: string
    licensePlate: string
    drivershift?: drivershiftCreateNestedManyWithoutCarInput
  }

  export type carUncheckedCreateInput = {
    uuid?: string
    modelName: string
    modelDescription?: string | null
    manufactureYear: Date | string
    seat?: number
    color?: string | null
    carImage: string
    licensePlate: string
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutCarInput
  }

  export type carUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelDescription?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureYear?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    carImage?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    drivershift?: drivershiftUpdateManyWithoutCarNestedInput
  }

  export type carUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelDescription?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureYear?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    carImage?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    drivershift?: drivershiftUncheckedUpdateManyWithoutCarNestedInput
  }

  export type carCreateManyInput = {
    uuid?: string
    modelName: string
    modelDescription?: string | null
    manufactureYear: Date | string
    seat?: number
    color?: string | null
    carImage: string
    licensePlate: string
  }

  export type carUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelDescription?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureYear?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    carImage?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type carUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelDescription?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureYear?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    carImage?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type customerCreateInput = {
    uuid?: string
    state?: string
    user?: userCreateNestedOneWithoutCustomerInput
  }

  export type customerUncheckedCreateInput = {
    uuid?: string
    userId?: string | null
    state?: string
  }

  export type customerUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
  }

  export type customerCreateManyInput = {
    uuid?: string
    userId?: string | null
    state?: string
  }

  export type customerUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type customerUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
  }

  export type driverCreateInput = {
    uuid?: string
    drivingLicenceNumber: string
    expiryDate: Date | string
    state?: string
    user: userCreateNestedOneWithoutDriverInput
  }

  export type driverUncheckedCreateInput = {
    uuid?: string
    userId: string
    drivingLicenceNumber: string
    expiryDate: Date | string
    state?: string
  }

  export type driverUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    drivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutDriverNestedInput
  }

  export type driverUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    drivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type driverCreateManyInput = {
    uuid?: string
    userId: string
    drivingLicenceNumber: string
    expiryDate: Date | string
    state?: string
  }

  export type driverUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    drivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type driverUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    drivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type drivershiftCreateInput = {
    uuid?: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
    user: userCreateNestedOneWithoutDrivershiftInput
    car: carCreateNestedOneWithoutDrivershiftInput
    ridestatus?: ridestatusCreateNestedManyWithoutDrivershiftInput
  }

  export type drivershiftUncheckedCreateInput = {
    uuid?: string
    driverId: string
    carId: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutDrivershiftInput
  }

  export type drivershiftUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutDrivershiftNestedInput
    car?: carUpdateOneRequiredWithoutDrivershiftNestedInput
    ridestatus?: ridestatusUpdateManyWithoutDrivershiftNestedInput
  }

  export type drivershiftUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ridestatus?: ridestatusUncheckedUpdateManyWithoutDrivershiftNestedInput
  }

  export type drivershiftCreateManyInput = {
    uuid?: string
    driverId: string
    carId: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
  }

  export type drivershiftUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type drivershiftUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageCreateInput = {
    uuid?: string
    sendingTime?: Date | string
    message: string
    ride: rideCreateNestedOneWithoutMessageInput
    user_message_senderIdTouser: userCreateNestedOneWithoutMessage_message_senderIdTouserInput
    user_message_receiverIdTouser: userCreateNestedOneWithoutMessage_message_receiverIdTouserInput
  }

  export type messageUncheckedCreateInput = {
    uuid?: string
    rideId: string
    senderId: string
    receiverId: string
    sendingTime?: Date | string
    message: string
  }

  export type messageUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    ride?: rideUpdateOneRequiredWithoutMessageNestedInput
    user_message_senderIdTouser?: userUpdateOneRequiredWithoutMessage_message_senderIdTouserNestedInput
    user_message_receiverIdTouser?: userUpdateOneRequiredWithoutMessage_message_receiverIdTouserNestedInput
  }

  export type messageUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type messageCreateManyInput = {
    uuid?: string
    rideId: string
    senderId: string
    receiverId: string
    sendingTime?: Date | string
    message: string
  }

  export type messageUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type messageUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ratingCreateInput = {
    uuid?: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
    ride: rideCreateNestedOneWithoutRatingInput
    user_rating_driverIdTouser: userCreateNestedOneWithoutRating_rating_driverIdTouserInput
    user_rating_userIdTouser: userCreateNestedOneWithoutRating_rating_userIdTouserInput
  }

  export type ratingUncheckedCreateInput = {
    uuid?: string
    rideId: string
    driverId: string
    userId: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
  }

  export type ratingUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: rideUpdateOneRequiredWithoutRatingNestedInput
    user_rating_driverIdTouser?: userUpdateOneRequiredWithoutRating_rating_driverIdTouserNestedInput
    user_rating_userIdTouser?: userUpdateOneRequiredWithoutRating_rating_userIdTouserNestedInput
  }

  export type ratingUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingCreateManyInput = {
    uuid?: string
    rideId: string
    driverId: string
    userId: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
  }

  export type ratingUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rideCreateInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    phone: string
    seat?: number
    rideStartTime?: Date | string
    rideEndTime?: Date | string | null
    startingPoint: string
    destinationPoint: string
    distance?: number | null
    price?: number | null
    note?: string | null
    message?: messageCreateNestedManyWithoutRideInput
    rating?: ratingCreateNestedManyWithoutRideInput
    ridestatus?: ridestatusCreateNestedManyWithoutRideInput
  }

  export type rideUncheckedCreateInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    phone: string
    seat?: number
    rideStartTime?: Date | string
    rideEndTime?: Date | string | null
    startingPoint: string
    destinationPoint: string
    distance?: number | null
    price?: number | null
    note?: string | null
    message?: messageUncheckedCreateNestedManyWithoutRideInput
    rating?: ratingUncheckedCreateNestedManyWithoutRideInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutRideInput
  }

  export type rideUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    message?: messageUpdateManyWithoutRideNestedInput
    rating?: ratingUpdateManyWithoutRideNestedInput
    ridestatus?: ridestatusUpdateManyWithoutRideNestedInput
  }

  export type rideUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    message?: messageUncheckedUpdateManyWithoutRideNestedInput
    rating?: ratingUncheckedUpdateManyWithoutRideNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutRideNestedInput
  }

  export type rideCreateManyInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    phone: string
    seat?: number
    rideStartTime?: Date | string
    rideEndTime?: Date | string | null
    startingPoint: string
    destinationPoint: string
    distance?: number | null
    price?: number | null
    note?: string | null
  }

  export type rideUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rideUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ridestatusCreateInput = {
    uuid?: string
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
    ride: rideCreateNestedOneWithoutRidestatusInput
    user?: userCreateNestedOneWithoutRidestatusInput
    drivershift?: drivershiftCreateNestedOneWithoutRidestatusInput
  }

  export type ridestatusUncheckedCreateInput = {
    uuid?: string
    rideId: string
    driverId?: string | null
    driverShiftId?: string | null
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
  }

  export type ridestatusUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
    ride?: rideUpdateOneRequiredWithoutRidestatusNestedInput
    user?: userUpdateOneWithoutRidestatusNestedInput
    drivershift?: drivershiftUpdateOneWithoutRidestatusNestedInput
  }

  export type ridestatusUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ridestatusCreateManyInput = {
    uuid?: string
    rideId: string
    driverId?: string | null
    driverShiftId?: string | null
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
  }

  export type ridestatusUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ridestatusUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
  }

  export type userUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type callCountOrderByAggregateInput = {
    uuid?: SortOrder
    userCallId?: SortOrder
    userAnswerId?: SortOrder
    beginCallingTime?: SortOrder
    endCallingTime?: SortOrder
    callingStatus?: SortOrder
  }

  export type callMaxOrderByAggregateInput = {
    uuid?: SortOrder
    userCallId?: SortOrder
    userAnswerId?: SortOrder
    beginCallingTime?: SortOrder
    endCallingTime?: SortOrder
    callingStatus?: SortOrder
  }

  export type callMinOrderByAggregateInput = {
    uuid?: SortOrder
    userCallId?: SortOrder
    userAnswerId?: SortOrder
    beginCallingTime?: SortOrder
    endCallingTime?: SortOrder
    callingStatus?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type callcenteragentCountOrderByAggregateInput = {
    uuid?: SortOrder
    userId?: SortOrder
    state?: SortOrder
  }

  export type callcenteragentMaxOrderByAggregateInput = {
    uuid?: SortOrder
    userId?: SortOrder
    state?: SortOrder
  }

  export type callcenteragentMinOrderByAggregateInput = {
    uuid?: SortOrder
    userId?: SortOrder
    state?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DrivershiftListRelationFilter = {
    every?: drivershiftWhereInput
    some?: drivershiftWhereInput
    none?: drivershiftWhereInput
  }

  export type drivershiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type carCountOrderByAggregateInput = {
    uuid?: SortOrder
    modelName?: SortOrder
    modelDescription?: SortOrder
    manufactureYear?: SortOrder
    seat?: SortOrder
    color?: SortOrder
    carImage?: SortOrder
    licensePlate?: SortOrder
  }

  export type carAvgOrderByAggregateInput = {
    seat?: SortOrder
  }

  export type carMaxOrderByAggregateInput = {
    uuid?: SortOrder
    modelName?: SortOrder
    modelDescription?: SortOrder
    manufactureYear?: SortOrder
    seat?: SortOrder
    color?: SortOrder
    carImage?: SortOrder
    licensePlate?: SortOrder
  }

  export type carMinOrderByAggregateInput = {
    uuid?: SortOrder
    modelName?: SortOrder
    modelDescription?: SortOrder
    manufactureYear?: SortOrder
    seat?: SortOrder
    color?: SortOrder
    carImage?: SortOrder
    licensePlate?: SortOrder
  }

  export type carSumOrderByAggregateInput = {
    seat?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type customerCountOrderByAggregateInput = {
    uuid?: SortOrder
    userId?: SortOrder
    state?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    uuid?: SortOrder
    userId?: SortOrder
    state?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    uuid?: SortOrder
    userId?: SortOrder
    state?: SortOrder
  }

  export type driverCountOrderByAggregateInput = {
    uuid?: SortOrder
    userId?: SortOrder
    drivingLicenceNumber?: SortOrder
    expiryDate?: SortOrder
    state?: SortOrder
  }

  export type driverMaxOrderByAggregateInput = {
    uuid?: SortOrder
    userId?: SortOrder
    drivingLicenceNumber?: SortOrder
    expiryDate?: SortOrder
    state?: SortOrder
  }

  export type driverMinOrderByAggregateInput = {
    uuid?: SortOrder
    userId?: SortOrder
    drivingLicenceNumber?: SortOrder
    expiryDate?: SortOrder
    state?: SortOrder
  }

  export type CarRelationFilter = {
    is?: carWhereInput
    isNot?: carWhereInput
  }

  export type RidestatusListRelationFilter = {
    every?: ridestatusWhereInput
    some?: ridestatusWhereInput
    none?: ridestatusWhereInput
  }

  export type ridestatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type drivershiftCountOrderByAggregateInput = {
    uuid?: SortOrder
    driverId?: SortOrder
    carId?: SortOrder
    shiftStartTime?: SortOrder
    shiftEndTime?: SortOrder
    createdAt?: SortOrder
  }

  export type drivershiftMaxOrderByAggregateInput = {
    uuid?: SortOrder
    driverId?: SortOrder
    carId?: SortOrder
    shiftStartTime?: SortOrder
    shiftEndTime?: SortOrder
    createdAt?: SortOrder
  }

  export type drivershiftMinOrderByAggregateInput = {
    uuid?: SortOrder
    driverId?: SortOrder
    carId?: SortOrder
    shiftStartTime?: SortOrder
    shiftEndTime?: SortOrder
    createdAt?: SortOrder
  }

  export type RideRelationFilter = {
    is?: rideWhereInput
    isNot?: rideWhereInput
  }

  export type messageCountOrderByAggregateInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    sendingTime?: SortOrder
    message?: SortOrder
  }

  export type messageMaxOrderByAggregateInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    sendingTime?: SortOrder
    message?: SortOrder
  }

  export type messageMinOrderByAggregateInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    sendingTime?: SortOrder
    message?: SortOrder
  }

  export type ratingCountOrderByAggregateInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrder
    userId?: SortOrder
    ratingComment?: SortOrder
    ratingTag?: SortOrder
    ratingValue?: SortOrder
    ratingTime?: SortOrder
  }

  export type ratingAvgOrderByAggregateInput = {
    ratingValue?: SortOrder
  }

  export type ratingMaxOrderByAggregateInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrder
    userId?: SortOrder
    ratingComment?: SortOrder
    ratingTag?: SortOrder
    ratingValue?: SortOrder
    ratingTime?: SortOrder
  }

  export type ratingMinOrderByAggregateInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrder
    userId?: SortOrder
    ratingComment?: SortOrder
    ratingTag?: SortOrder
    ratingValue?: SortOrder
    ratingTime?: SortOrder
  }

  export type ratingSumOrderByAggregateInput = {
    ratingValue?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MessageListRelationFilter = {
    every?: messageWhereInput
    some?: messageWhereInput
    none?: messageWhereInput
  }

  export type RatingListRelationFilter = {
    every?: ratingWhereInput
    some?: ratingWhereInput
    none?: ratingWhereInput
  }

  export type messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ratingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rideCountOrderByAggregateInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    seat?: SortOrder
    rideStartTime?: SortOrder
    rideEndTime?: SortOrder
    startingPoint?: SortOrder
    destinationPoint?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    note?: SortOrder
  }

  export type rideAvgOrderByAggregateInput = {
    seat?: SortOrder
    distance?: SortOrder
    price?: SortOrder
  }

  export type rideMaxOrderByAggregateInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    seat?: SortOrder
    rideStartTime?: SortOrder
    rideEndTime?: SortOrder
    startingPoint?: SortOrder
    destinationPoint?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    note?: SortOrder
  }

  export type rideMinOrderByAggregateInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    seat?: SortOrder
    rideStartTime?: SortOrder
    rideEndTime?: SortOrder
    startingPoint?: SortOrder
    destinationPoint?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    note?: SortOrder
  }

  export type rideSumOrderByAggregateInput = {
    seat?: SortOrder
    distance?: SortOrder
    price?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DrivershiftNullableRelationFilter = {
    is?: drivershiftWhereInput | null
    isNot?: drivershiftWhereInput | null
  }

  export type ridestatusCountOrderByAggregateInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrder
    driverShiftId?: SortOrder
    state?: SortOrder
    stateTime?: SortOrder
    stateDetail?: SortOrder
  }

  export type ridestatusMaxOrderByAggregateInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrder
    driverShiftId?: SortOrder
    state?: SortOrder
    stateTime?: SortOrder
    stateDetail?: SortOrder
  }

  export type ridestatusMinOrderByAggregateInput = {
    uuid?: SortOrder
    rideId?: SortOrder
    driverId?: SortOrder
    driverShiftId?: SortOrder
    state?: SortOrder
    stateTime?: SortOrder
    stateDetail?: SortOrder
  }

  export type CallListRelationFilter = {
    every?: callWhereInput
    some?: callWhereInput
    none?: callWhereInput
  }

  export type CallcenteragentListRelationFilter = {
    every?: callcenteragentWhereInput
    some?: callcenteragentWhereInput
    none?: callcenteragentWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: customerWhereInput
    some?: customerWhereInput
    none?: customerWhereInput
  }

  export type DriverListRelationFilter = {
    every?: driverWhereInput
    some?: driverWhereInput
    none?: driverWhereInput
  }

  export type callOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type callcenteragentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type driverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    dob?: SortOrder
    cic?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    dob?: SortOrder
    cic?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    uuid?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    dob?: SortOrder
    cic?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
  }

  export type userCreateNestedOneWithoutCall_call_userCallIdTouserInput = {
    create?: XOR<userCreateWithoutCall_call_userCallIdTouserInput, userUncheckedCreateWithoutCall_call_userCallIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutCall_call_userCallIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutCall_call_userAnswerIdTouserInput = {
    create?: XOR<userCreateWithoutCall_call_userAnswerIdTouserInput, userUncheckedCreateWithoutCall_call_userAnswerIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutCall_call_userAnswerIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userUpdateOneRequiredWithoutCall_call_userCallIdTouserNestedInput = {
    create?: XOR<userCreateWithoutCall_call_userCallIdTouserInput, userUncheckedCreateWithoutCall_call_userCallIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutCall_call_userCallIdTouserInput
    upsert?: userUpsertWithoutCall_call_userCallIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCall_call_userCallIdTouserInput, userUpdateWithoutCall_call_userCallIdTouserInput>, userUncheckedUpdateWithoutCall_call_userCallIdTouserInput>
  }

  export type userUpdateOneRequiredWithoutCall_call_userAnswerIdTouserNestedInput = {
    create?: XOR<userCreateWithoutCall_call_userAnswerIdTouserInput, userUncheckedCreateWithoutCall_call_userAnswerIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutCall_call_userAnswerIdTouserInput
    upsert?: userUpsertWithoutCall_call_userAnswerIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCall_call_userAnswerIdTouserInput, userUpdateWithoutCall_call_userAnswerIdTouserInput>, userUncheckedUpdateWithoutCall_call_userAnswerIdTouserInput>
  }

  export type userCreateNestedOneWithoutCallcenteragentInput = {
    create?: XOR<userCreateWithoutCallcenteragentInput, userUncheckedCreateWithoutCallcenteragentInput>
    connectOrCreate?: userCreateOrConnectWithoutCallcenteragentInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCallcenteragentNestedInput = {
    create?: XOR<userCreateWithoutCallcenteragentInput, userUncheckedCreateWithoutCallcenteragentInput>
    connectOrCreate?: userCreateOrConnectWithoutCallcenteragentInput
    upsert?: userUpsertWithoutCallcenteragentInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCallcenteragentInput, userUpdateWithoutCallcenteragentInput>, userUncheckedUpdateWithoutCallcenteragentInput>
  }

  export type drivershiftCreateNestedManyWithoutCarInput = {
    create?: XOR<drivershiftCreateWithoutCarInput, drivershiftUncheckedCreateWithoutCarInput> | drivershiftCreateWithoutCarInput[] | drivershiftUncheckedCreateWithoutCarInput[]
    connectOrCreate?: drivershiftCreateOrConnectWithoutCarInput | drivershiftCreateOrConnectWithoutCarInput[]
    createMany?: drivershiftCreateManyCarInputEnvelope
    connect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
  }

  export type drivershiftUncheckedCreateNestedManyWithoutCarInput = {
    create?: XOR<drivershiftCreateWithoutCarInput, drivershiftUncheckedCreateWithoutCarInput> | drivershiftCreateWithoutCarInput[] | drivershiftUncheckedCreateWithoutCarInput[]
    connectOrCreate?: drivershiftCreateOrConnectWithoutCarInput | drivershiftCreateOrConnectWithoutCarInput[]
    createMany?: drivershiftCreateManyCarInputEnvelope
    connect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type drivershiftUpdateManyWithoutCarNestedInput = {
    create?: XOR<drivershiftCreateWithoutCarInput, drivershiftUncheckedCreateWithoutCarInput> | drivershiftCreateWithoutCarInput[] | drivershiftUncheckedCreateWithoutCarInput[]
    connectOrCreate?: drivershiftCreateOrConnectWithoutCarInput | drivershiftCreateOrConnectWithoutCarInput[]
    upsert?: drivershiftUpsertWithWhereUniqueWithoutCarInput | drivershiftUpsertWithWhereUniqueWithoutCarInput[]
    createMany?: drivershiftCreateManyCarInputEnvelope
    set?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    disconnect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    delete?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    connect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    update?: drivershiftUpdateWithWhereUniqueWithoutCarInput | drivershiftUpdateWithWhereUniqueWithoutCarInput[]
    updateMany?: drivershiftUpdateManyWithWhereWithoutCarInput | drivershiftUpdateManyWithWhereWithoutCarInput[]
    deleteMany?: drivershiftScalarWhereInput | drivershiftScalarWhereInput[]
  }

  export type drivershiftUncheckedUpdateManyWithoutCarNestedInput = {
    create?: XOR<drivershiftCreateWithoutCarInput, drivershiftUncheckedCreateWithoutCarInput> | drivershiftCreateWithoutCarInput[] | drivershiftUncheckedCreateWithoutCarInput[]
    connectOrCreate?: drivershiftCreateOrConnectWithoutCarInput | drivershiftCreateOrConnectWithoutCarInput[]
    upsert?: drivershiftUpsertWithWhereUniqueWithoutCarInput | drivershiftUpsertWithWhereUniqueWithoutCarInput[]
    createMany?: drivershiftCreateManyCarInputEnvelope
    set?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    disconnect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    delete?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    connect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    update?: drivershiftUpdateWithWhereUniqueWithoutCarInput | drivershiftUpdateWithWhereUniqueWithoutCarInput[]
    updateMany?: drivershiftUpdateManyWithWhereWithoutCarInput | drivershiftUpdateManyWithWhereWithoutCarInput[]
    deleteMany?: drivershiftScalarWhereInput | drivershiftScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutCustomerInput = {
    create?: XOR<userCreateWithoutCustomerInput, userUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: userCreateOrConnectWithoutCustomerInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<userCreateWithoutCustomerInput, userUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: userCreateOrConnectWithoutCustomerInput
    upsert?: userUpsertWithoutCustomerInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCustomerInput, userUpdateWithoutCustomerInput>, userUncheckedUpdateWithoutCustomerInput>
  }

  export type userCreateNestedOneWithoutDriverInput = {
    create?: XOR<userCreateWithoutDriverInput, userUncheckedCreateWithoutDriverInput>
    connectOrCreate?: userCreateOrConnectWithoutDriverInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutDriverNestedInput = {
    create?: XOR<userCreateWithoutDriverInput, userUncheckedCreateWithoutDriverInput>
    connectOrCreate?: userCreateOrConnectWithoutDriverInput
    upsert?: userUpsertWithoutDriverInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutDriverInput, userUpdateWithoutDriverInput>, userUncheckedUpdateWithoutDriverInput>
  }

  export type userCreateNestedOneWithoutDrivershiftInput = {
    create?: XOR<userCreateWithoutDrivershiftInput, userUncheckedCreateWithoutDrivershiftInput>
    connectOrCreate?: userCreateOrConnectWithoutDrivershiftInput
    connect?: userWhereUniqueInput
  }

  export type carCreateNestedOneWithoutDrivershiftInput = {
    create?: XOR<carCreateWithoutDrivershiftInput, carUncheckedCreateWithoutDrivershiftInput>
    connectOrCreate?: carCreateOrConnectWithoutDrivershiftInput
    connect?: carWhereUniqueInput
  }

  export type ridestatusCreateNestedManyWithoutDrivershiftInput = {
    create?: XOR<ridestatusCreateWithoutDrivershiftInput, ridestatusUncheckedCreateWithoutDrivershiftInput> | ridestatusCreateWithoutDrivershiftInput[] | ridestatusUncheckedCreateWithoutDrivershiftInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutDrivershiftInput | ridestatusCreateOrConnectWithoutDrivershiftInput[]
    createMany?: ridestatusCreateManyDrivershiftInputEnvelope
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
  }

  export type ridestatusUncheckedCreateNestedManyWithoutDrivershiftInput = {
    create?: XOR<ridestatusCreateWithoutDrivershiftInput, ridestatusUncheckedCreateWithoutDrivershiftInput> | ridestatusCreateWithoutDrivershiftInput[] | ridestatusUncheckedCreateWithoutDrivershiftInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutDrivershiftInput | ridestatusCreateOrConnectWithoutDrivershiftInput[]
    createMany?: ridestatusCreateManyDrivershiftInputEnvelope
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutDrivershiftNestedInput = {
    create?: XOR<userCreateWithoutDrivershiftInput, userUncheckedCreateWithoutDrivershiftInput>
    connectOrCreate?: userCreateOrConnectWithoutDrivershiftInput
    upsert?: userUpsertWithoutDrivershiftInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutDrivershiftInput, userUpdateWithoutDrivershiftInput>, userUncheckedUpdateWithoutDrivershiftInput>
  }

  export type carUpdateOneRequiredWithoutDrivershiftNestedInput = {
    create?: XOR<carCreateWithoutDrivershiftInput, carUncheckedCreateWithoutDrivershiftInput>
    connectOrCreate?: carCreateOrConnectWithoutDrivershiftInput
    upsert?: carUpsertWithoutDrivershiftInput
    connect?: carWhereUniqueInput
    update?: XOR<XOR<carUpdateToOneWithWhereWithoutDrivershiftInput, carUpdateWithoutDrivershiftInput>, carUncheckedUpdateWithoutDrivershiftInput>
  }

  export type ridestatusUpdateManyWithoutDrivershiftNestedInput = {
    create?: XOR<ridestatusCreateWithoutDrivershiftInput, ridestatusUncheckedCreateWithoutDrivershiftInput> | ridestatusCreateWithoutDrivershiftInput[] | ridestatusUncheckedCreateWithoutDrivershiftInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutDrivershiftInput | ridestatusCreateOrConnectWithoutDrivershiftInput[]
    upsert?: ridestatusUpsertWithWhereUniqueWithoutDrivershiftInput | ridestatusUpsertWithWhereUniqueWithoutDrivershiftInput[]
    createMany?: ridestatusCreateManyDrivershiftInputEnvelope
    set?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    disconnect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    delete?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    update?: ridestatusUpdateWithWhereUniqueWithoutDrivershiftInput | ridestatusUpdateWithWhereUniqueWithoutDrivershiftInput[]
    updateMany?: ridestatusUpdateManyWithWhereWithoutDrivershiftInput | ridestatusUpdateManyWithWhereWithoutDrivershiftInput[]
    deleteMany?: ridestatusScalarWhereInput | ridestatusScalarWhereInput[]
  }

  export type ridestatusUncheckedUpdateManyWithoutDrivershiftNestedInput = {
    create?: XOR<ridestatusCreateWithoutDrivershiftInput, ridestatusUncheckedCreateWithoutDrivershiftInput> | ridestatusCreateWithoutDrivershiftInput[] | ridestatusUncheckedCreateWithoutDrivershiftInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutDrivershiftInput | ridestatusCreateOrConnectWithoutDrivershiftInput[]
    upsert?: ridestatusUpsertWithWhereUniqueWithoutDrivershiftInput | ridestatusUpsertWithWhereUniqueWithoutDrivershiftInput[]
    createMany?: ridestatusCreateManyDrivershiftInputEnvelope
    set?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    disconnect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    delete?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    update?: ridestatusUpdateWithWhereUniqueWithoutDrivershiftInput | ridestatusUpdateWithWhereUniqueWithoutDrivershiftInput[]
    updateMany?: ridestatusUpdateManyWithWhereWithoutDrivershiftInput | ridestatusUpdateManyWithWhereWithoutDrivershiftInput[]
    deleteMany?: ridestatusScalarWhereInput | ridestatusScalarWhereInput[]
  }

  export type rideCreateNestedOneWithoutMessageInput = {
    create?: XOR<rideCreateWithoutMessageInput, rideUncheckedCreateWithoutMessageInput>
    connectOrCreate?: rideCreateOrConnectWithoutMessageInput
    connect?: rideWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMessage_message_senderIdTouserInput = {
    create?: XOR<userCreateWithoutMessage_message_senderIdTouserInput, userUncheckedCreateWithoutMessage_message_senderIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutMessage_message_senderIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMessage_message_receiverIdTouserInput = {
    create?: XOR<userCreateWithoutMessage_message_receiverIdTouserInput, userUncheckedCreateWithoutMessage_message_receiverIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutMessage_message_receiverIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type rideUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<rideCreateWithoutMessageInput, rideUncheckedCreateWithoutMessageInput>
    connectOrCreate?: rideCreateOrConnectWithoutMessageInput
    upsert?: rideUpsertWithoutMessageInput
    connect?: rideWhereUniqueInput
    update?: XOR<XOR<rideUpdateToOneWithWhereWithoutMessageInput, rideUpdateWithoutMessageInput>, rideUncheckedUpdateWithoutMessageInput>
  }

  export type userUpdateOneRequiredWithoutMessage_message_senderIdTouserNestedInput = {
    create?: XOR<userCreateWithoutMessage_message_senderIdTouserInput, userUncheckedCreateWithoutMessage_message_senderIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutMessage_message_senderIdTouserInput
    upsert?: userUpsertWithoutMessage_message_senderIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutMessage_message_senderIdTouserInput, userUpdateWithoutMessage_message_senderIdTouserInput>, userUncheckedUpdateWithoutMessage_message_senderIdTouserInput>
  }

  export type userUpdateOneRequiredWithoutMessage_message_receiverIdTouserNestedInput = {
    create?: XOR<userCreateWithoutMessage_message_receiverIdTouserInput, userUncheckedCreateWithoutMessage_message_receiverIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutMessage_message_receiverIdTouserInput
    upsert?: userUpsertWithoutMessage_message_receiverIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutMessage_message_receiverIdTouserInput, userUpdateWithoutMessage_message_receiverIdTouserInput>, userUncheckedUpdateWithoutMessage_message_receiverIdTouserInput>
  }

  export type rideCreateNestedOneWithoutRatingInput = {
    create?: XOR<rideCreateWithoutRatingInput, rideUncheckedCreateWithoutRatingInput>
    connectOrCreate?: rideCreateOrConnectWithoutRatingInput
    connect?: rideWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRating_rating_driverIdTouserInput = {
    create?: XOR<userCreateWithoutRating_rating_driverIdTouserInput, userUncheckedCreateWithoutRating_rating_driverIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutRating_rating_driverIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRating_rating_userIdTouserInput = {
    create?: XOR<userCreateWithoutRating_rating_userIdTouserInput, userUncheckedCreateWithoutRating_rating_userIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutRating_rating_userIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type rideUpdateOneRequiredWithoutRatingNestedInput = {
    create?: XOR<rideCreateWithoutRatingInput, rideUncheckedCreateWithoutRatingInput>
    connectOrCreate?: rideCreateOrConnectWithoutRatingInput
    upsert?: rideUpsertWithoutRatingInput
    connect?: rideWhereUniqueInput
    update?: XOR<XOR<rideUpdateToOneWithWhereWithoutRatingInput, rideUpdateWithoutRatingInput>, rideUncheckedUpdateWithoutRatingInput>
  }

  export type userUpdateOneRequiredWithoutRating_rating_driverIdTouserNestedInput = {
    create?: XOR<userCreateWithoutRating_rating_driverIdTouserInput, userUncheckedCreateWithoutRating_rating_driverIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutRating_rating_driverIdTouserInput
    upsert?: userUpsertWithoutRating_rating_driverIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRating_rating_driverIdTouserInput, userUpdateWithoutRating_rating_driverIdTouserInput>, userUncheckedUpdateWithoutRating_rating_driverIdTouserInput>
  }

  export type userUpdateOneRequiredWithoutRating_rating_userIdTouserNestedInput = {
    create?: XOR<userCreateWithoutRating_rating_userIdTouserInput, userUncheckedCreateWithoutRating_rating_userIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutRating_rating_userIdTouserInput
    upsert?: userUpsertWithoutRating_rating_userIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRating_rating_userIdTouserInput, userUpdateWithoutRating_rating_userIdTouserInput>, userUncheckedUpdateWithoutRating_rating_userIdTouserInput>
  }

  export type messageCreateNestedManyWithoutRideInput = {
    create?: XOR<messageCreateWithoutRideInput, messageUncheckedCreateWithoutRideInput> | messageCreateWithoutRideInput[] | messageUncheckedCreateWithoutRideInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRideInput | messageCreateOrConnectWithoutRideInput[]
    createMany?: messageCreateManyRideInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type ratingCreateNestedManyWithoutRideInput = {
    create?: XOR<ratingCreateWithoutRideInput, ratingUncheckedCreateWithoutRideInput> | ratingCreateWithoutRideInput[] | ratingUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutRideInput | ratingCreateOrConnectWithoutRideInput[]
    createMany?: ratingCreateManyRideInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type ridestatusCreateNestedManyWithoutRideInput = {
    create?: XOR<ridestatusCreateWithoutRideInput, ridestatusUncheckedCreateWithoutRideInput> | ridestatusCreateWithoutRideInput[] | ridestatusUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutRideInput | ridestatusCreateOrConnectWithoutRideInput[]
    createMany?: ridestatusCreateManyRideInputEnvelope
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<messageCreateWithoutRideInput, messageUncheckedCreateWithoutRideInput> | messageCreateWithoutRideInput[] | messageUncheckedCreateWithoutRideInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRideInput | messageCreateOrConnectWithoutRideInput[]
    createMany?: messageCreateManyRideInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type ratingUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<ratingCreateWithoutRideInput, ratingUncheckedCreateWithoutRideInput> | ratingCreateWithoutRideInput[] | ratingUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutRideInput | ratingCreateOrConnectWithoutRideInput[]
    createMany?: ratingCreateManyRideInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type ridestatusUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<ridestatusCreateWithoutRideInput, ridestatusUncheckedCreateWithoutRideInput> | ridestatusCreateWithoutRideInput[] | ridestatusUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutRideInput | ridestatusCreateOrConnectWithoutRideInput[]
    createMany?: ridestatusCreateManyRideInputEnvelope
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type messageUpdateManyWithoutRideNestedInput = {
    create?: XOR<messageCreateWithoutRideInput, messageUncheckedCreateWithoutRideInput> | messageCreateWithoutRideInput[] | messageUncheckedCreateWithoutRideInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRideInput | messageCreateOrConnectWithoutRideInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutRideInput | messageUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: messageCreateManyRideInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutRideInput | messageUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: messageUpdateManyWithWhereWithoutRideInput | messageUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type ratingUpdateManyWithoutRideNestedInput = {
    create?: XOR<ratingCreateWithoutRideInput, ratingUncheckedCreateWithoutRideInput> | ratingCreateWithoutRideInput[] | ratingUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutRideInput | ratingCreateOrConnectWithoutRideInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutRideInput | ratingUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: ratingCreateManyRideInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutRideInput | ratingUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutRideInput | ratingUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type ridestatusUpdateManyWithoutRideNestedInput = {
    create?: XOR<ridestatusCreateWithoutRideInput, ridestatusUncheckedCreateWithoutRideInput> | ridestatusCreateWithoutRideInput[] | ridestatusUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutRideInput | ridestatusCreateOrConnectWithoutRideInput[]
    upsert?: ridestatusUpsertWithWhereUniqueWithoutRideInput | ridestatusUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: ridestatusCreateManyRideInputEnvelope
    set?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    disconnect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    delete?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    update?: ridestatusUpdateWithWhereUniqueWithoutRideInput | ridestatusUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: ridestatusUpdateManyWithWhereWithoutRideInput | ridestatusUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: ridestatusScalarWhereInput | ridestatusScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<messageCreateWithoutRideInput, messageUncheckedCreateWithoutRideInput> | messageCreateWithoutRideInput[] | messageUncheckedCreateWithoutRideInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRideInput | messageCreateOrConnectWithoutRideInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutRideInput | messageUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: messageCreateManyRideInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutRideInput | messageUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: messageUpdateManyWithWhereWithoutRideInput | messageUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type ratingUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<ratingCreateWithoutRideInput, ratingUncheckedCreateWithoutRideInput> | ratingCreateWithoutRideInput[] | ratingUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutRideInput | ratingCreateOrConnectWithoutRideInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutRideInput | ratingUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: ratingCreateManyRideInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutRideInput | ratingUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutRideInput | ratingUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type ridestatusUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<ridestatusCreateWithoutRideInput, ridestatusUncheckedCreateWithoutRideInput> | ridestatusCreateWithoutRideInput[] | ridestatusUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutRideInput | ridestatusCreateOrConnectWithoutRideInput[]
    upsert?: ridestatusUpsertWithWhereUniqueWithoutRideInput | ridestatusUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: ridestatusCreateManyRideInputEnvelope
    set?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    disconnect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    delete?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    update?: ridestatusUpdateWithWhereUniqueWithoutRideInput | ridestatusUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: ridestatusUpdateManyWithWhereWithoutRideInput | ridestatusUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: ridestatusScalarWhereInput | ridestatusScalarWhereInput[]
  }

  export type rideCreateNestedOneWithoutRidestatusInput = {
    create?: XOR<rideCreateWithoutRidestatusInput, rideUncheckedCreateWithoutRidestatusInput>
    connectOrCreate?: rideCreateOrConnectWithoutRidestatusInput
    connect?: rideWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRidestatusInput = {
    create?: XOR<userCreateWithoutRidestatusInput, userUncheckedCreateWithoutRidestatusInput>
    connectOrCreate?: userCreateOrConnectWithoutRidestatusInput
    connect?: userWhereUniqueInput
  }

  export type drivershiftCreateNestedOneWithoutRidestatusInput = {
    create?: XOR<drivershiftCreateWithoutRidestatusInput, drivershiftUncheckedCreateWithoutRidestatusInput>
    connectOrCreate?: drivershiftCreateOrConnectWithoutRidestatusInput
    connect?: drivershiftWhereUniqueInput
  }

  export type rideUpdateOneRequiredWithoutRidestatusNestedInput = {
    create?: XOR<rideCreateWithoutRidestatusInput, rideUncheckedCreateWithoutRidestatusInput>
    connectOrCreate?: rideCreateOrConnectWithoutRidestatusInput
    upsert?: rideUpsertWithoutRidestatusInput
    connect?: rideWhereUniqueInput
    update?: XOR<XOR<rideUpdateToOneWithWhereWithoutRidestatusInput, rideUpdateWithoutRidestatusInput>, rideUncheckedUpdateWithoutRidestatusInput>
  }

  export type userUpdateOneWithoutRidestatusNestedInput = {
    create?: XOR<userCreateWithoutRidestatusInput, userUncheckedCreateWithoutRidestatusInput>
    connectOrCreate?: userCreateOrConnectWithoutRidestatusInput
    upsert?: userUpsertWithoutRidestatusInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRidestatusInput, userUpdateWithoutRidestatusInput>, userUncheckedUpdateWithoutRidestatusInput>
  }

  export type drivershiftUpdateOneWithoutRidestatusNestedInput = {
    create?: XOR<drivershiftCreateWithoutRidestatusInput, drivershiftUncheckedCreateWithoutRidestatusInput>
    connectOrCreate?: drivershiftCreateOrConnectWithoutRidestatusInput
    upsert?: drivershiftUpsertWithoutRidestatusInput
    disconnect?: drivershiftWhereInput | boolean
    delete?: drivershiftWhereInput | boolean
    connect?: drivershiftWhereUniqueInput
    update?: XOR<XOR<drivershiftUpdateToOneWithWhereWithoutRidestatusInput, drivershiftUpdateWithoutRidestatusInput>, drivershiftUncheckedUpdateWithoutRidestatusInput>
  }

  export type callCreateNestedManyWithoutUser_call_userCallIdTouserInput = {
    create?: XOR<callCreateWithoutUser_call_userCallIdTouserInput, callUncheckedCreateWithoutUser_call_userCallIdTouserInput> | callCreateWithoutUser_call_userCallIdTouserInput[] | callUncheckedCreateWithoutUser_call_userCallIdTouserInput[]
    connectOrCreate?: callCreateOrConnectWithoutUser_call_userCallIdTouserInput | callCreateOrConnectWithoutUser_call_userCallIdTouserInput[]
    createMany?: callCreateManyUser_call_userCallIdTouserInputEnvelope
    connect?: callWhereUniqueInput | callWhereUniqueInput[]
  }

  export type callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput = {
    create?: XOR<callCreateWithoutUser_call_userAnswerIdTouserInput, callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput> | callCreateWithoutUser_call_userAnswerIdTouserInput[] | callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput[]
    connectOrCreate?: callCreateOrConnectWithoutUser_call_userAnswerIdTouserInput | callCreateOrConnectWithoutUser_call_userAnswerIdTouserInput[]
    createMany?: callCreateManyUser_call_userAnswerIdTouserInputEnvelope
    connect?: callWhereUniqueInput | callWhereUniqueInput[]
  }

  export type callcenteragentCreateNestedManyWithoutUserInput = {
    create?: XOR<callcenteragentCreateWithoutUserInput, callcenteragentUncheckedCreateWithoutUserInput> | callcenteragentCreateWithoutUserInput[] | callcenteragentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: callcenteragentCreateOrConnectWithoutUserInput | callcenteragentCreateOrConnectWithoutUserInput[]
    createMany?: callcenteragentCreateManyUserInputEnvelope
    connect?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
  }

  export type customerCreateNestedManyWithoutUserInput = {
    create?: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput> | customerCreateWithoutUserInput[] | customerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: customerCreateOrConnectWithoutUserInput | customerCreateOrConnectWithoutUserInput[]
    createMany?: customerCreateManyUserInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type driverCreateNestedManyWithoutUserInput = {
    create?: XOR<driverCreateWithoutUserInput, driverUncheckedCreateWithoutUserInput> | driverCreateWithoutUserInput[] | driverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: driverCreateOrConnectWithoutUserInput | driverCreateOrConnectWithoutUserInput[]
    createMany?: driverCreateManyUserInputEnvelope
    connect?: driverWhereUniqueInput | driverWhereUniqueInput[]
  }

  export type drivershiftCreateNestedManyWithoutUserInput = {
    create?: XOR<drivershiftCreateWithoutUserInput, drivershiftUncheckedCreateWithoutUserInput> | drivershiftCreateWithoutUserInput[] | drivershiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: drivershiftCreateOrConnectWithoutUserInput | drivershiftCreateOrConnectWithoutUserInput[]
    createMany?: drivershiftCreateManyUserInputEnvelope
    connect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutUser_message_senderIdTouserInput = {
    create?: XOR<messageCreateWithoutUser_message_senderIdTouserInput, messageUncheckedCreateWithoutUser_message_senderIdTouserInput> | messageCreateWithoutUser_message_senderIdTouserInput[] | messageUncheckedCreateWithoutUser_message_senderIdTouserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUser_message_senderIdTouserInput | messageCreateOrConnectWithoutUser_message_senderIdTouserInput[]
    createMany?: messageCreateManyUser_message_senderIdTouserInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutUser_message_receiverIdTouserInput = {
    create?: XOR<messageCreateWithoutUser_message_receiverIdTouserInput, messageUncheckedCreateWithoutUser_message_receiverIdTouserInput> | messageCreateWithoutUser_message_receiverIdTouserInput[] | messageUncheckedCreateWithoutUser_message_receiverIdTouserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUser_message_receiverIdTouserInput | messageCreateOrConnectWithoutUser_message_receiverIdTouserInput[]
    createMany?: messageCreateManyUser_message_receiverIdTouserInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput = {
    create?: XOR<ratingCreateWithoutUser_rating_driverIdTouserInput, ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput> | ratingCreateWithoutUser_rating_driverIdTouserInput[] | ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutUser_rating_driverIdTouserInput | ratingCreateOrConnectWithoutUser_rating_driverIdTouserInput[]
    createMany?: ratingCreateManyUser_rating_driverIdTouserInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type ratingCreateNestedManyWithoutUser_rating_userIdTouserInput = {
    create?: XOR<ratingCreateWithoutUser_rating_userIdTouserInput, ratingUncheckedCreateWithoutUser_rating_userIdTouserInput> | ratingCreateWithoutUser_rating_userIdTouserInput[] | ratingUncheckedCreateWithoutUser_rating_userIdTouserInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutUser_rating_userIdTouserInput | ratingCreateOrConnectWithoutUser_rating_userIdTouserInput[]
    createMany?: ratingCreateManyUser_rating_userIdTouserInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type ridestatusCreateNestedManyWithoutUserInput = {
    create?: XOR<ridestatusCreateWithoutUserInput, ridestatusUncheckedCreateWithoutUserInput> | ridestatusCreateWithoutUserInput[] | ridestatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutUserInput | ridestatusCreateOrConnectWithoutUserInput[]
    createMany?: ridestatusCreateManyUserInputEnvelope
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
  }

  export type callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput = {
    create?: XOR<callCreateWithoutUser_call_userCallIdTouserInput, callUncheckedCreateWithoutUser_call_userCallIdTouserInput> | callCreateWithoutUser_call_userCallIdTouserInput[] | callUncheckedCreateWithoutUser_call_userCallIdTouserInput[]
    connectOrCreate?: callCreateOrConnectWithoutUser_call_userCallIdTouserInput | callCreateOrConnectWithoutUser_call_userCallIdTouserInput[]
    createMany?: callCreateManyUser_call_userCallIdTouserInputEnvelope
    connect?: callWhereUniqueInput | callWhereUniqueInput[]
  }

  export type callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput = {
    create?: XOR<callCreateWithoutUser_call_userAnswerIdTouserInput, callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput> | callCreateWithoutUser_call_userAnswerIdTouserInput[] | callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput[]
    connectOrCreate?: callCreateOrConnectWithoutUser_call_userAnswerIdTouserInput | callCreateOrConnectWithoutUser_call_userAnswerIdTouserInput[]
    createMany?: callCreateManyUser_call_userAnswerIdTouserInputEnvelope
    connect?: callWhereUniqueInput | callWhereUniqueInput[]
  }

  export type callcenteragentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<callcenteragentCreateWithoutUserInput, callcenteragentUncheckedCreateWithoutUserInput> | callcenteragentCreateWithoutUserInput[] | callcenteragentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: callcenteragentCreateOrConnectWithoutUserInput | callcenteragentCreateOrConnectWithoutUserInput[]
    createMany?: callcenteragentCreateManyUserInputEnvelope
    connect?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
  }

  export type customerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput> | customerCreateWithoutUserInput[] | customerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: customerCreateOrConnectWithoutUserInput | customerCreateOrConnectWithoutUserInput[]
    createMany?: customerCreateManyUserInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type driverUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<driverCreateWithoutUserInput, driverUncheckedCreateWithoutUserInput> | driverCreateWithoutUserInput[] | driverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: driverCreateOrConnectWithoutUserInput | driverCreateOrConnectWithoutUserInput[]
    createMany?: driverCreateManyUserInputEnvelope
    connect?: driverWhereUniqueInput | driverWhereUniqueInput[]
  }

  export type drivershiftUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<drivershiftCreateWithoutUserInput, drivershiftUncheckedCreateWithoutUserInput> | drivershiftCreateWithoutUserInput[] | drivershiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: drivershiftCreateOrConnectWithoutUserInput | drivershiftCreateOrConnectWithoutUserInput[]
    createMany?: drivershiftCreateManyUserInputEnvelope
    connect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput = {
    create?: XOR<messageCreateWithoutUser_message_senderIdTouserInput, messageUncheckedCreateWithoutUser_message_senderIdTouserInput> | messageCreateWithoutUser_message_senderIdTouserInput[] | messageUncheckedCreateWithoutUser_message_senderIdTouserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUser_message_senderIdTouserInput | messageCreateOrConnectWithoutUser_message_senderIdTouserInput[]
    createMany?: messageCreateManyUser_message_senderIdTouserInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput = {
    create?: XOR<messageCreateWithoutUser_message_receiverIdTouserInput, messageUncheckedCreateWithoutUser_message_receiverIdTouserInput> | messageCreateWithoutUser_message_receiverIdTouserInput[] | messageUncheckedCreateWithoutUser_message_receiverIdTouserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUser_message_receiverIdTouserInput | messageCreateOrConnectWithoutUser_message_receiverIdTouserInput[]
    createMany?: messageCreateManyUser_message_receiverIdTouserInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput = {
    create?: XOR<ratingCreateWithoutUser_rating_driverIdTouserInput, ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput> | ratingCreateWithoutUser_rating_driverIdTouserInput[] | ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutUser_rating_driverIdTouserInput | ratingCreateOrConnectWithoutUser_rating_driverIdTouserInput[]
    createMany?: ratingCreateManyUser_rating_driverIdTouserInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput = {
    create?: XOR<ratingCreateWithoutUser_rating_userIdTouserInput, ratingUncheckedCreateWithoutUser_rating_userIdTouserInput> | ratingCreateWithoutUser_rating_userIdTouserInput[] | ratingUncheckedCreateWithoutUser_rating_userIdTouserInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutUser_rating_userIdTouserInput | ratingCreateOrConnectWithoutUser_rating_userIdTouserInput[]
    createMany?: ratingCreateManyUser_rating_userIdTouserInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type ridestatusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ridestatusCreateWithoutUserInput, ridestatusUncheckedCreateWithoutUserInput> | ridestatusCreateWithoutUserInput[] | ridestatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutUserInput | ridestatusCreateOrConnectWithoutUserInput[]
    createMany?: ridestatusCreateManyUserInputEnvelope
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
  }

  export type callUpdateManyWithoutUser_call_userCallIdTouserNestedInput = {
    create?: XOR<callCreateWithoutUser_call_userCallIdTouserInput, callUncheckedCreateWithoutUser_call_userCallIdTouserInput> | callCreateWithoutUser_call_userCallIdTouserInput[] | callUncheckedCreateWithoutUser_call_userCallIdTouserInput[]
    connectOrCreate?: callCreateOrConnectWithoutUser_call_userCallIdTouserInput | callCreateOrConnectWithoutUser_call_userCallIdTouserInput[]
    upsert?: callUpsertWithWhereUniqueWithoutUser_call_userCallIdTouserInput | callUpsertWithWhereUniqueWithoutUser_call_userCallIdTouserInput[]
    createMany?: callCreateManyUser_call_userCallIdTouserInputEnvelope
    set?: callWhereUniqueInput | callWhereUniqueInput[]
    disconnect?: callWhereUniqueInput | callWhereUniqueInput[]
    delete?: callWhereUniqueInput | callWhereUniqueInput[]
    connect?: callWhereUniqueInput | callWhereUniqueInput[]
    update?: callUpdateWithWhereUniqueWithoutUser_call_userCallIdTouserInput | callUpdateWithWhereUniqueWithoutUser_call_userCallIdTouserInput[]
    updateMany?: callUpdateManyWithWhereWithoutUser_call_userCallIdTouserInput | callUpdateManyWithWhereWithoutUser_call_userCallIdTouserInput[]
    deleteMany?: callScalarWhereInput | callScalarWhereInput[]
  }

  export type callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput = {
    create?: XOR<callCreateWithoutUser_call_userAnswerIdTouserInput, callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput> | callCreateWithoutUser_call_userAnswerIdTouserInput[] | callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput[]
    connectOrCreate?: callCreateOrConnectWithoutUser_call_userAnswerIdTouserInput | callCreateOrConnectWithoutUser_call_userAnswerIdTouserInput[]
    upsert?: callUpsertWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput | callUpsertWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput[]
    createMany?: callCreateManyUser_call_userAnswerIdTouserInputEnvelope
    set?: callWhereUniqueInput | callWhereUniqueInput[]
    disconnect?: callWhereUniqueInput | callWhereUniqueInput[]
    delete?: callWhereUniqueInput | callWhereUniqueInput[]
    connect?: callWhereUniqueInput | callWhereUniqueInput[]
    update?: callUpdateWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput | callUpdateWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput[]
    updateMany?: callUpdateManyWithWhereWithoutUser_call_userAnswerIdTouserInput | callUpdateManyWithWhereWithoutUser_call_userAnswerIdTouserInput[]
    deleteMany?: callScalarWhereInput | callScalarWhereInput[]
  }

  export type callcenteragentUpdateManyWithoutUserNestedInput = {
    create?: XOR<callcenteragentCreateWithoutUserInput, callcenteragentUncheckedCreateWithoutUserInput> | callcenteragentCreateWithoutUserInput[] | callcenteragentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: callcenteragentCreateOrConnectWithoutUserInput | callcenteragentCreateOrConnectWithoutUserInput[]
    upsert?: callcenteragentUpsertWithWhereUniqueWithoutUserInput | callcenteragentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: callcenteragentCreateManyUserInputEnvelope
    set?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
    disconnect?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
    delete?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
    connect?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
    update?: callcenteragentUpdateWithWhereUniqueWithoutUserInput | callcenteragentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: callcenteragentUpdateManyWithWhereWithoutUserInput | callcenteragentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: callcenteragentScalarWhereInput | callcenteragentScalarWhereInput[]
  }

  export type customerUpdateManyWithoutUserNestedInput = {
    create?: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput> | customerCreateWithoutUserInput[] | customerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: customerCreateOrConnectWithoutUserInput | customerCreateOrConnectWithoutUserInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutUserInput | customerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: customerCreateManyUserInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutUserInput | customerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: customerUpdateManyWithWhereWithoutUserInput | customerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type driverUpdateManyWithoutUserNestedInput = {
    create?: XOR<driverCreateWithoutUserInput, driverUncheckedCreateWithoutUserInput> | driverCreateWithoutUserInput[] | driverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: driverCreateOrConnectWithoutUserInput | driverCreateOrConnectWithoutUserInput[]
    upsert?: driverUpsertWithWhereUniqueWithoutUserInput | driverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: driverCreateManyUserInputEnvelope
    set?: driverWhereUniqueInput | driverWhereUniqueInput[]
    disconnect?: driverWhereUniqueInput | driverWhereUniqueInput[]
    delete?: driverWhereUniqueInput | driverWhereUniqueInput[]
    connect?: driverWhereUniqueInput | driverWhereUniqueInput[]
    update?: driverUpdateWithWhereUniqueWithoutUserInput | driverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: driverUpdateManyWithWhereWithoutUserInput | driverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: driverScalarWhereInput | driverScalarWhereInput[]
  }

  export type drivershiftUpdateManyWithoutUserNestedInput = {
    create?: XOR<drivershiftCreateWithoutUserInput, drivershiftUncheckedCreateWithoutUserInput> | drivershiftCreateWithoutUserInput[] | drivershiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: drivershiftCreateOrConnectWithoutUserInput | drivershiftCreateOrConnectWithoutUserInput[]
    upsert?: drivershiftUpsertWithWhereUniqueWithoutUserInput | drivershiftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: drivershiftCreateManyUserInputEnvelope
    set?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    disconnect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    delete?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    connect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    update?: drivershiftUpdateWithWhereUniqueWithoutUserInput | drivershiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: drivershiftUpdateManyWithWhereWithoutUserInput | drivershiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: drivershiftScalarWhereInput | drivershiftScalarWhereInput[]
  }

  export type messageUpdateManyWithoutUser_message_senderIdTouserNestedInput = {
    create?: XOR<messageCreateWithoutUser_message_senderIdTouserInput, messageUncheckedCreateWithoutUser_message_senderIdTouserInput> | messageCreateWithoutUser_message_senderIdTouserInput[] | messageUncheckedCreateWithoutUser_message_senderIdTouserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUser_message_senderIdTouserInput | messageCreateOrConnectWithoutUser_message_senderIdTouserInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutUser_message_senderIdTouserInput | messageUpsertWithWhereUniqueWithoutUser_message_senderIdTouserInput[]
    createMany?: messageCreateManyUser_message_senderIdTouserInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutUser_message_senderIdTouserInput | messageUpdateWithWhereUniqueWithoutUser_message_senderIdTouserInput[]
    updateMany?: messageUpdateManyWithWhereWithoutUser_message_senderIdTouserInput | messageUpdateManyWithWhereWithoutUser_message_senderIdTouserInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput = {
    create?: XOR<messageCreateWithoutUser_message_receiverIdTouserInput, messageUncheckedCreateWithoutUser_message_receiverIdTouserInput> | messageCreateWithoutUser_message_receiverIdTouserInput[] | messageUncheckedCreateWithoutUser_message_receiverIdTouserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUser_message_receiverIdTouserInput | messageCreateOrConnectWithoutUser_message_receiverIdTouserInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutUser_message_receiverIdTouserInput | messageUpsertWithWhereUniqueWithoutUser_message_receiverIdTouserInput[]
    createMany?: messageCreateManyUser_message_receiverIdTouserInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutUser_message_receiverIdTouserInput | messageUpdateWithWhereUniqueWithoutUser_message_receiverIdTouserInput[]
    updateMany?: messageUpdateManyWithWhereWithoutUser_message_receiverIdTouserInput | messageUpdateManyWithWhereWithoutUser_message_receiverIdTouserInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput = {
    create?: XOR<ratingCreateWithoutUser_rating_driverIdTouserInput, ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput> | ratingCreateWithoutUser_rating_driverIdTouserInput[] | ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutUser_rating_driverIdTouserInput | ratingCreateOrConnectWithoutUser_rating_driverIdTouserInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutUser_rating_driverIdTouserInput | ratingUpsertWithWhereUniqueWithoutUser_rating_driverIdTouserInput[]
    createMany?: ratingCreateManyUser_rating_driverIdTouserInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutUser_rating_driverIdTouserInput | ratingUpdateWithWhereUniqueWithoutUser_rating_driverIdTouserInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutUser_rating_driverIdTouserInput | ratingUpdateManyWithWhereWithoutUser_rating_driverIdTouserInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput = {
    create?: XOR<ratingCreateWithoutUser_rating_userIdTouserInput, ratingUncheckedCreateWithoutUser_rating_userIdTouserInput> | ratingCreateWithoutUser_rating_userIdTouserInput[] | ratingUncheckedCreateWithoutUser_rating_userIdTouserInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutUser_rating_userIdTouserInput | ratingCreateOrConnectWithoutUser_rating_userIdTouserInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutUser_rating_userIdTouserInput | ratingUpsertWithWhereUniqueWithoutUser_rating_userIdTouserInput[]
    createMany?: ratingCreateManyUser_rating_userIdTouserInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutUser_rating_userIdTouserInput | ratingUpdateWithWhereUniqueWithoutUser_rating_userIdTouserInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutUser_rating_userIdTouserInput | ratingUpdateManyWithWhereWithoutUser_rating_userIdTouserInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type ridestatusUpdateManyWithoutUserNestedInput = {
    create?: XOR<ridestatusCreateWithoutUserInput, ridestatusUncheckedCreateWithoutUserInput> | ridestatusCreateWithoutUserInput[] | ridestatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutUserInput | ridestatusCreateOrConnectWithoutUserInput[]
    upsert?: ridestatusUpsertWithWhereUniqueWithoutUserInput | ridestatusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ridestatusCreateManyUserInputEnvelope
    set?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    disconnect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    delete?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    update?: ridestatusUpdateWithWhereUniqueWithoutUserInput | ridestatusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ridestatusUpdateManyWithWhereWithoutUserInput | ridestatusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ridestatusScalarWhereInput | ridestatusScalarWhereInput[]
  }

  export type callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput = {
    create?: XOR<callCreateWithoutUser_call_userCallIdTouserInput, callUncheckedCreateWithoutUser_call_userCallIdTouserInput> | callCreateWithoutUser_call_userCallIdTouserInput[] | callUncheckedCreateWithoutUser_call_userCallIdTouserInput[]
    connectOrCreate?: callCreateOrConnectWithoutUser_call_userCallIdTouserInput | callCreateOrConnectWithoutUser_call_userCallIdTouserInput[]
    upsert?: callUpsertWithWhereUniqueWithoutUser_call_userCallIdTouserInput | callUpsertWithWhereUniqueWithoutUser_call_userCallIdTouserInput[]
    createMany?: callCreateManyUser_call_userCallIdTouserInputEnvelope
    set?: callWhereUniqueInput | callWhereUniqueInput[]
    disconnect?: callWhereUniqueInput | callWhereUniqueInput[]
    delete?: callWhereUniqueInput | callWhereUniqueInput[]
    connect?: callWhereUniqueInput | callWhereUniqueInput[]
    update?: callUpdateWithWhereUniqueWithoutUser_call_userCallIdTouserInput | callUpdateWithWhereUniqueWithoutUser_call_userCallIdTouserInput[]
    updateMany?: callUpdateManyWithWhereWithoutUser_call_userCallIdTouserInput | callUpdateManyWithWhereWithoutUser_call_userCallIdTouserInput[]
    deleteMany?: callScalarWhereInput | callScalarWhereInput[]
  }

  export type callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput = {
    create?: XOR<callCreateWithoutUser_call_userAnswerIdTouserInput, callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput> | callCreateWithoutUser_call_userAnswerIdTouserInput[] | callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput[]
    connectOrCreate?: callCreateOrConnectWithoutUser_call_userAnswerIdTouserInput | callCreateOrConnectWithoutUser_call_userAnswerIdTouserInput[]
    upsert?: callUpsertWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput | callUpsertWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput[]
    createMany?: callCreateManyUser_call_userAnswerIdTouserInputEnvelope
    set?: callWhereUniqueInput | callWhereUniqueInput[]
    disconnect?: callWhereUniqueInput | callWhereUniqueInput[]
    delete?: callWhereUniqueInput | callWhereUniqueInput[]
    connect?: callWhereUniqueInput | callWhereUniqueInput[]
    update?: callUpdateWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput | callUpdateWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput[]
    updateMany?: callUpdateManyWithWhereWithoutUser_call_userAnswerIdTouserInput | callUpdateManyWithWhereWithoutUser_call_userAnswerIdTouserInput[]
    deleteMany?: callScalarWhereInput | callScalarWhereInput[]
  }

  export type callcenteragentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<callcenteragentCreateWithoutUserInput, callcenteragentUncheckedCreateWithoutUserInput> | callcenteragentCreateWithoutUserInput[] | callcenteragentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: callcenteragentCreateOrConnectWithoutUserInput | callcenteragentCreateOrConnectWithoutUserInput[]
    upsert?: callcenteragentUpsertWithWhereUniqueWithoutUserInput | callcenteragentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: callcenteragentCreateManyUserInputEnvelope
    set?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
    disconnect?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
    delete?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
    connect?: callcenteragentWhereUniqueInput | callcenteragentWhereUniqueInput[]
    update?: callcenteragentUpdateWithWhereUniqueWithoutUserInput | callcenteragentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: callcenteragentUpdateManyWithWhereWithoutUserInput | callcenteragentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: callcenteragentScalarWhereInput | callcenteragentScalarWhereInput[]
  }

  export type customerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput> | customerCreateWithoutUserInput[] | customerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: customerCreateOrConnectWithoutUserInput | customerCreateOrConnectWithoutUserInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutUserInput | customerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: customerCreateManyUserInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutUserInput | customerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: customerUpdateManyWithWhereWithoutUserInput | customerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type driverUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<driverCreateWithoutUserInput, driverUncheckedCreateWithoutUserInput> | driverCreateWithoutUserInput[] | driverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: driverCreateOrConnectWithoutUserInput | driverCreateOrConnectWithoutUserInput[]
    upsert?: driverUpsertWithWhereUniqueWithoutUserInput | driverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: driverCreateManyUserInputEnvelope
    set?: driverWhereUniqueInput | driverWhereUniqueInput[]
    disconnect?: driverWhereUniqueInput | driverWhereUniqueInput[]
    delete?: driverWhereUniqueInput | driverWhereUniqueInput[]
    connect?: driverWhereUniqueInput | driverWhereUniqueInput[]
    update?: driverUpdateWithWhereUniqueWithoutUserInput | driverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: driverUpdateManyWithWhereWithoutUserInput | driverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: driverScalarWhereInput | driverScalarWhereInput[]
  }

  export type drivershiftUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<drivershiftCreateWithoutUserInput, drivershiftUncheckedCreateWithoutUserInput> | drivershiftCreateWithoutUserInput[] | drivershiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: drivershiftCreateOrConnectWithoutUserInput | drivershiftCreateOrConnectWithoutUserInput[]
    upsert?: drivershiftUpsertWithWhereUniqueWithoutUserInput | drivershiftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: drivershiftCreateManyUserInputEnvelope
    set?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    disconnect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    delete?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    connect?: drivershiftWhereUniqueInput | drivershiftWhereUniqueInput[]
    update?: drivershiftUpdateWithWhereUniqueWithoutUserInput | drivershiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: drivershiftUpdateManyWithWhereWithoutUserInput | drivershiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: drivershiftScalarWhereInput | drivershiftScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput = {
    create?: XOR<messageCreateWithoutUser_message_senderIdTouserInput, messageUncheckedCreateWithoutUser_message_senderIdTouserInput> | messageCreateWithoutUser_message_senderIdTouserInput[] | messageUncheckedCreateWithoutUser_message_senderIdTouserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUser_message_senderIdTouserInput | messageCreateOrConnectWithoutUser_message_senderIdTouserInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutUser_message_senderIdTouserInput | messageUpsertWithWhereUniqueWithoutUser_message_senderIdTouserInput[]
    createMany?: messageCreateManyUser_message_senderIdTouserInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutUser_message_senderIdTouserInput | messageUpdateWithWhereUniqueWithoutUser_message_senderIdTouserInput[]
    updateMany?: messageUpdateManyWithWhereWithoutUser_message_senderIdTouserInput | messageUpdateManyWithWhereWithoutUser_message_senderIdTouserInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput = {
    create?: XOR<messageCreateWithoutUser_message_receiverIdTouserInput, messageUncheckedCreateWithoutUser_message_receiverIdTouserInput> | messageCreateWithoutUser_message_receiverIdTouserInput[] | messageUncheckedCreateWithoutUser_message_receiverIdTouserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUser_message_receiverIdTouserInput | messageCreateOrConnectWithoutUser_message_receiverIdTouserInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutUser_message_receiverIdTouserInput | messageUpsertWithWhereUniqueWithoutUser_message_receiverIdTouserInput[]
    createMany?: messageCreateManyUser_message_receiverIdTouserInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutUser_message_receiverIdTouserInput | messageUpdateWithWhereUniqueWithoutUser_message_receiverIdTouserInput[]
    updateMany?: messageUpdateManyWithWhereWithoutUser_message_receiverIdTouserInput | messageUpdateManyWithWhereWithoutUser_message_receiverIdTouserInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput = {
    create?: XOR<ratingCreateWithoutUser_rating_driverIdTouserInput, ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput> | ratingCreateWithoutUser_rating_driverIdTouserInput[] | ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutUser_rating_driverIdTouserInput | ratingCreateOrConnectWithoutUser_rating_driverIdTouserInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutUser_rating_driverIdTouserInput | ratingUpsertWithWhereUniqueWithoutUser_rating_driverIdTouserInput[]
    createMany?: ratingCreateManyUser_rating_driverIdTouserInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutUser_rating_driverIdTouserInput | ratingUpdateWithWhereUniqueWithoutUser_rating_driverIdTouserInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutUser_rating_driverIdTouserInput | ratingUpdateManyWithWhereWithoutUser_rating_driverIdTouserInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput = {
    create?: XOR<ratingCreateWithoutUser_rating_userIdTouserInput, ratingUncheckedCreateWithoutUser_rating_userIdTouserInput> | ratingCreateWithoutUser_rating_userIdTouserInput[] | ratingUncheckedCreateWithoutUser_rating_userIdTouserInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutUser_rating_userIdTouserInput | ratingCreateOrConnectWithoutUser_rating_userIdTouserInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutUser_rating_userIdTouserInput | ratingUpsertWithWhereUniqueWithoutUser_rating_userIdTouserInput[]
    createMany?: ratingCreateManyUser_rating_userIdTouserInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutUser_rating_userIdTouserInput | ratingUpdateWithWhereUniqueWithoutUser_rating_userIdTouserInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutUser_rating_userIdTouserInput | ratingUpdateManyWithWhereWithoutUser_rating_userIdTouserInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type ridestatusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ridestatusCreateWithoutUserInput, ridestatusUncheckedCreateWithoutUserInput> | ridestatusCreateWithoutUserInput[] | ridestatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ridestatusCreateOrConnectWithoutUserInput | ridestatusCreateOrConnectWithoutUserInput[]
    upsert?: ridestatusUpsertWithWhereUniqueWithoutUserInput | ridestatusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ridestatusCreateManyUserInputEnvelope
    set?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    disconnect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    delete?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    connect?: ridestatusWhereUniqueInput | ridestatusWhereUniqueInput[]
    update?: ridestatusUpdateWithWhereUniqueWithoutUserInput | ridestatusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ridestatusUpdateManyWithWhereWithoutUserInput | ridestatusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ridestatusScalarWhereInput | ridestatusScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type userCreateWithoutCall_call_userCallIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCall_call_userCallIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCall_call_userCallIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCall_call_userCallIdTouserInput, userUncheckedCreateWithoutCall_call_userCallIdTouserInput>
  }

  export type userCreateWithoutCall_call_userAnswerIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCall_call_userAnswerIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCall_call_userAnswerIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCall_call_userAnswerIdTouserInput, userUncheckedCreateWithoutCall_call_userAnswerIdTouserInput>
  }

  export type userUpsertWithoutCall_call_userCallIdTouserInput = {
    update: XOR<userUpdateWithoutCall_call_userCallIdTouserInput, userUncheckedUpdateWithoutCall_call_userCallIdTouserInput>
    create: XOR<userCreateWithoutCall_call_userCallIdTouserInput, userUncheckedCreateWithoutCall_call_userCallIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCall_call_userCallIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCall_call_userCallIdTouserInput, userUncheckedUpdateWithoutCall_call_userCallIdTouserInput>
  }

  export type userUpdateWithoutCall_call_userCallIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCall_call_userCallIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutCall_call_userAnswerIdTouserInput = {
    update: XOR<userUpdateWithoutCall_call_userAnswerIdTouserInput, userUncheckedUpdateWithoutCall_call_userAnswerIdTouserInput>
    create: XOR<userCreateWithoutCall_call_userAnswerIdTouserInput, userUncheckedCreateWithoutCall_call_userAnswerIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCall_call_userAnswerIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCall_call_userAnswerIdTouserInput, userUncheckedUpdateWithoutCall_call_userAnswerIdTouserInput>
  }

  export type userUpdateWithoutCall_call_userAnswerIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCall_call_userAnswerIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutCallcenteragentInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCallcenteragentInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCallcenteragentInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCallcenteragentInput, userUncheckedCreateWithoutCallcenteragentInput>
  }

  export type userUpsertWithoutCallcenteragentInput = {
    update: XOR<userUpdateWithoutCallcenteragentInput, userUncheckedUpdateWithoutCallcenteragentInput>
    create: XOR<userCreateWithoutCallcenteragentInput, userUncheckedCreateWithoutCallcenteragentInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCallcenteragentInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCallcenteragentInput, userUncheckedUpdateWithoutCallcenteragentInput>
  }

  export type userUpdateWithoutCallcenteragentInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCallcenteragentInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type drivershiftCreateWithoutCarInput = {
    uuid?: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
    user: userCreateNestedOneWithoutDrivershiftInput
    ridestatus?: ridestatusCreateNestedManyWithoutDrivershiftInput
  }

  export type drivershiftUncheckedCreateWithoutCarInput = {
    uuid?: string
    driverId: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutDrivershiftInput
  }

  export type drivershiftCreateOrConnectWithoutCarInput = {
    where: drivershiftWhereUniqueInput
    create: XOR<drivershiftCreateWithoutCarInput, drivershiftUncheckedCreateWithoutCarInput>
  }

  export type drivershiftCreateManyCarInputEnvelope = {
    data: drivershiftCreateManyCarInput | drivershiftCreateManyCarInput[]
    skipDuplicates?: boolean
  }

  export type drivershiftUpsertWithWhereUniqueWithoutCarInput = {
    where: drivershiftWhereUniqueInput
    update: XOR<drivershiftUpdateWithoutCarInput, drivershiftUncheckedUpdateWithoutCarInput>
    create: XOR<drivershiftCreateWithoutCarInput, drivershiftUncheckedCreateWithoutCarInput>
  }

  export type drivershiftUpdateWithWhereUniqueWithoutCarInput = {
    where: drivershiftWhereUniqueInput
    data: XOR<drivershiftUpdateWithoutCarInput, drivershiftUncheckedUpdateWithoutCarInput>
  }

  export type drivershiftUpdateManyWithWhereWithoutCarInput = {
    where: drivershiftScalarWhereInput
    data: XOR<drivershiftUpdateManyMutationInput, drivershiftUncheckedUpdateManyWithoutCarInput>
  }

  export type drivershiftScalarWhereInput = {
    AND?: drivershiftScalarWhereInput | drivershiftScalarWhereInput[]
    OR?: drivershiftScalarWhereInput[]
    NOT?: drivershiftScalarWhereInput | drivershiftScalarWhereInput[]
    uuid?: StringFilter<"drivershift"> | string
    driverId?: StringFilter<"drivershift"> | string
    carId?: StringFilter<"drivershift"> | string
    shiftStartTime?: DateTimeFilter<"drivershift"> | Date | string
    shiftEndTime?: DateTimeFilter<"drivershift"> | Date | string
    createdAt?: DateTimeNullableFilter<"drivershift"> | Date | string | null
  }

  export type userCreateWithoutCustomerInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCustomerInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCustomerInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCustomerInput, userUncheckedCreateWithoutCustomerInput>
  }

  export type userUpsertWithoutCustomerInput = {
    update: XOR<userUpdateWithoutCustomerInput, userUncheckedUpdateWithoutCustomerInput>
    create: XOR<userCreateWithoutCustomerInput, userUncheckedCreateWithoutCustomerInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCustomerInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCustomerInput, userUncheckedUpdateWithoutCustomerInput>
  }

  export type userUpdateWithoutCustomerInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCustomerInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutDriverInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutDriverInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutDriverInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutDriverInput, userUncheckedCreateWithoutDriverInput>
  }

  export type userUpsertWithoutDriverInput = {
    update: XOR<userUpdateWithoutDriverInput, userUncheckedUpdateWithoutDriverInput>
    create: XOR<userCreateWithoutDriverInput, userUncheckedCreateWithoutDriverInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutDriverInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutDriverInput, userUncheckedUpdateWithoutDriverInput>
  }

  export type userUpdateWithoutDriverInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutDriverInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutDrivershiftInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutDrivershiftInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutDrivershiftInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutDrivershiftInput, userUncheckedCreateWithoutDrivershiftInput>
  }

  export type carCreateWithoutDrivershiftInput = {
    uuid?: string
    modelName: string
    modelDescription?: string | null
    manufactureYear: Date | string
    seat?: number
    color?: string | null
    carImage: string
    licensePlate: string
  }

  export type carUncheckedCreateWithoutDrivershiftInput = {
    uuid?: string
    modelName: string
    modelDescription?: string | null
    manufactureYear: Date | string
    seat?: number
    color?: string | null
    carImage: string
    licensePlate: string
  }

  export type carCreateOrConnectWithoutDrivershiftInput = {
    where: carWhereUniqueInput
    create: XOR<carCreateWithoutDrivershiftInput, carUncheckedCreateWithoutDrivershiftInput>
  }

  export type ridestatusCreateWithoutDrivershiftInput = {
    uuid?: string
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
    ride: rideCreateNestedOneWithoutRidestatusInput
    user?: userCreateNestedOneWithoutRidestatusInput
  }

  export type ridestatusUncheckedCreateWithoutDrivershiftInput = {
    uuid?: string
    rideId: string
    driverId?: string | null
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
  }

  export type ridestatusCreateOrConnectWithoutDrivershiftInput = {
    where: ridestatusWhereUniqueInput
    create: XOR<ridestatusCreateWithoutDrivershiftInput, ridestatusUncheckedCreateWithoutDrivershiftInput>
  }

  export type ridestatusCreateManyDrivershiftInputEnvelope = {
    data: ridestatusCreateManyDrivershiftInput | ridestatusCreateManyDrivershiftInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutDrivershiftInput = {
    update: XOR<userUpdateWithoutDrivershiftInput, userUncheckedUpdateWithoutDrivershiftInput>
    create: XOR<userCreateWithoutDrivershiftInput, userUncheckedCreateWithoutDrivershiftInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutDrivershiftInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutDrivershiftInput, userUncheckedUpdateWithoutDrivershiftInput>
  }

  export type userUpdateWithoutDrivershiftInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutDrivershiftInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type carUpsertWithoutDrivershiftInput = {
    update: XOR<carUpdateWithoutDrivershiftInput, carUncheckedUpdateWithoutDrivershiftInput>
    create: XOR<carCreateWithoutDrivershiftInput, carUncheckedCreateWithoutDrivershiftInput>
    where?: carWhereInput
  }

  export type carUpdateToOneWithWhereWithoutDrivershiftInput = {
    where?: carWhereInput
    data: XOR<carUpdateWithoutDrivershiftInput, carUncheckedUpdateWithoutDrivershiftInput>
  }

  export type carUpdateWithoutDrivershiftInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelDescription?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureYear?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    carImage?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type carUncheckedUpdateWithoutDrivershiftInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelDescription?: NullableStringFieldUpdateOperationsInput | string | null
    manufactureYear?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    carImage?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
  }

  export type ridestatusUpsertWithWhereUniqueWithoutDrivershiftInput = {
    where: ridestatusWhereUniqueInput
    update: XOR<ridestatusUpdateWithoutDrivershiftInput, ridestatusUncheckedUpdateWithoutDrivershiftInput>
    create: XOR<ridestatusCreateWithoutDrivershiftInput, ridestatusUncheckedCreateWithoutDrivershiftInput>
  }

  export type ridestatusUpdateWithWhereUniqueWithoutDrivershiftInput = {
    where: ridestatusWhereUniqueInput
    data: XOR<ridestatusUpdateWithoutDrivershiftInput, ridestatusUncheckedUpdateWithoutDrivershiftInput>
  }

  export type ridestatusUpdateManyWithWhereWithoutDrivershiftInput = {
    where: ridestatusScalarWhereInput
    data: XOR<ridestatusUpdateManyMutationInput, ridestatusUncheckedUpdateManyWithoutDrivershiftInput>
  }

  export type ridestatusScalarWhereInput = {
    AND?: ridestatusScalarWhereInput | ridestatusScalarWhereInput[]
    OR?: ridestatusScalarWhereInput[]
    NOT?: ridestatusScalarWhereInput | ridestatusScalarWhereInput[]
    uuid?: StringFilter<"ridestatus"> | string
    rideId?: StringFilter<"ridestatus"> | string
    driverId?: StringNullableFilter<"ridestatus"> | string | null
    driverShiftId?: StringNullableFilter<"ridestatus"> | string | null
    state?: StringFilter<"ridestatus"> | string
    stateTime?: DateTimeFilter<"ridestatus"> | Date | string
    stateDetail?: StringNullableFilter<"ridestatus"> | string | null
  }

  export type rideCreateWithoutMessageInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    phone: string
    seat?: number
    rideStartTime?: Date | string
    rideEndTime?: Date | string | null
    startingPoint: string
    destinationPoint: string
    distance?: number | null
    price?: number | null
    note?: string | null
    rating?: ratingCreateNestedManyWithoutRideInput
    ridestatus?: ridestatusCreateNestedManyWithoutRideInput
  }

  export type rideUncheckedCreateWithoutMessageInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    phone: string
    seat?: number
    rideStartTime?: Date | string
    rideEndTime?: Date | string | null
    startingPoint: string
    destinationPoint: string
    distance?: number | null
    price?: number | null
    note?: string | null
    rating?: ratingUncheckedCreateNestedManyWithoutRideInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutRideInput
  }

  export type rideCreateOrConnectWithoutMessageInput = {
    where: rideWhereUniqueInput
    create: XOR<rideCreateWithoutMessageInput, rideUncheckedCreateWithoutMessageInput>
  }

  export type userCreateWithoutMessage_message_senderIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMessage_message_senderIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMessage_message_senderIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMessage_message_senderIdTouserInput, userUncheckedCreateWithoutMessage_message_senderIdTouserInput>
  }

  export type userCreateWithoutMessage_message_receiverIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMessage_message_receiverIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMessage_message_receiverIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMessage_message_receiverIdTouserInput, userUncheckedCreateWithoutMessage_message_receiverIdTouserInput>
  }

  export type rideUpsertWithoutMessageInput = {
    update: XOR<rideUpdateWithoutMessageInput, rideUncheckedUpdateWithoutMessageInput>
    create: XOR<rideCreateWithoutMessageInput, rideUncheckedCreateWithoutMessageInput>
    where?: rideWhereInput
  }

  export type rideUpdateToOneWithWhereWithoutMessageInput = {
    where?: rideWhereInput
    data: XOR<rideUpdateWithoutMessageInput, rideUncheckedUpdateWithoutMessageInput>
  }

  export type rideUpdateWithoutMessageInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: ratingUpdateManyWithoutRideNestedInput
    ridestatus?: ridestatusUpdateManyWithoutRideNestedInput
  }

  export type rideUncheckedUpdateWithoutMessageInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: ratingUncheckedUpdateManyWithoutRideNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutRideNestedInput
  }

  export type userUpsertWithoutMessage_message_senderIdTouserInput = {
    update: XOR<userUpdateWithoutMessage_message_senderIdTouserInput, userUncheckedUpdateWithoutMessage_message_senderIdTouserInput>
    create: XOR<userCreateWithoutMessage_message_senderIdTouserInput, userUncheckedCreateWithoutMessage_message_senderIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutMessage_message_senderIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutMessage_message_senderIdTouserInput, userUncheckedUpdateWithoutMessage_message_senderIdTouserInput>
  }

  export type userUpdateWithoutMessage_message_senderIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMessage_message_senderIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutMessage_message_receiverIdTouserInput = {
    update: XOR<userUpdateWithoutMessage_message_receiverIdTouserInput, userUncheckedUpdateWithoutMessage_message_receiverIdTouserInput>
    create: XOR<userCreateWithoutMessage_message_receiverIdTouserInput, userUncheckedCreateWithoutMessage_message_receiverIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutMessage_message_receiverIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutMessage_message_receiverIdTouserInput, userUncheckedUpdateWithoutMessage_message_receiverIdTouserInput>
  }

  export type userUpdateWithoutMessage_message_receiverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMessage_message_receiverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type rideCreateWithoutRatingInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    phone: string
    seat?: number
    rideStartTime?: Date | string
    rideEndTime?: Date | string | null
    startingPoint: string
    destinationPoint: string
    distance?: number | null
    price?: number | null
    note?: string | null
    message?: messageCreateNestedManyWithoutRideInput
    ridestatus?: ridestatusCreateNestedManyWithoutRideInput
  }

  export type rideUncheckedCreateWithoutRatingInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    phone: string
    seat?: number
    rideStartTime?: Date | string
    rideEndTime?: Date | string | null
    startingPoint: string
    destinationPoint: string
    distance?: number | null
    price?: number | null
    note?: string | null
    message?: messageUncheckedCreateNestedManyWithoutRideInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutRideInput
  }

  export type rideCreateOrConnectWithoutRatingInput = {
    where: rideWhereUniqueInput
    create: XOR<rideCreateWithoutRatingInput, rideUncheckedCreateWithoutRatingInput>
  }

  export type userCreateWithoutRating_rating_driverIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRating_rating_driverIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRating_rating_driverIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRating_rating_driverIdTouserInput, userUncheckedCreateWithoutRating_rating_driverIdTouserInput>
  }

  export type userCreateWithoutRating_rating_userIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    ridestatus?: ridestatusCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRating_rating_userIdTouserInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRating_rating_userIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRating_rating_userIdTouserInput, userUncheckedCreateWithoutRating_rating_userIdTouserInput>
  }

  export type rideUpsertWithoutRatingInput = {
    update: XOR<rideUpdateWithoutRatingInput, rideUncheckedUpdateWithoutRatingInput>
    create: XOR<rideCreateWithoutRatingInput, rideUncheckedCreateWithoutRatingInput>
    where?: rideWhereInput
  }

  export type rideUpdateToOneWithWhereWithoutRatingInput = {
    where?: rideWhereInput
    data: XOR<rideUpdateWithoutRatingInput, rideUncheckedUpdateWithoutRatingInput>
  }

  export type rideUpdateWithoutRatingInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    message?: messageUpdateManyWithoutRideNestedInput
    ridestatus?: ridestatusUpdateManyWithoutRideNestedInput
  }

  export type rideUncheckedUpdateWithoutRatingInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    message?: messageUncheckedUpdateManyWithoutRideNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutRideNestedInput
  }

  export type userUpsertWithoutRating_rating_driverIdTouserInput = {
    update: XOR<userUpdateWithoutRating_rating_driverIdTouserInput, userUncheckedUpdateWithoutRating_rating_driverIdTouserInput>
    create: XOR<userCreateWithoutRating_rating_driverIdTouserInput, userUncheckedCreateWithoutRating_rating_driverIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRating_rating_driverIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRating_rating_driverIdTouserInput, userUncheckedUpdateWithoutRating_rating_driverIdTouserInput>
  }

  export type userUpdateWithoutRating_rating_driverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRating_rating_driverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutRating_rating_userIdTouserInput = {
    update: XOR<userUpdateWithoutRating_rating_userIdTouserInput, userUncheckedUpdateWithoutRating_rating_userIdTouserInput>
    create: XOR<userCreateWithoutRating_rating_userIdTouserInput, userUncheckedCreateWithoutRating_rating_userIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRating_rating_userIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRating_rating_userIdTouserInput, userUncheckedUpdateWithoutRating_rating_userIdTouserInput>
  }

  export type userUpdateWithoutRating_rating_userIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    ridestatus?: ridestatusUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRating_rating_userIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    ridestatus?: ridestatusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type messageCreateWithoutRideInput = {
    uuid?: string
    sendingTime?: Date | string
    message: string
    user_message_senderIdTouser: userCreateNestedOneWithoutMessage_message_senderIdTouserInput
    user_message_receiverIdTouser: userCreateNestedOneWithoutMessage_message_receiverIdTouserInput
  }

  export type messageUncheckedCreateWithoutRideInput = {
    uuid?: string
    senderId: string
    receiverId: string
    sendingTime?: Date | string
    message: string
  }

  export type messageCreateOrConnectWithoutRideInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutRideInput, messageUncheckedCreateWithoutRideInput>
  }

  export type messageCreateManyRideInputEnvelope = {
    data: messageCreateManyRideInput | messageCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type ratingCreateWithoutRideInput = {
    uuid?: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
    user_rating_driverIdTouser: userCreateNestedOneWithoutRating_rating_driverIdTouserInput
    user_rating_userIdTouser: userCreateNestedOneWithoutRating_rating_userIdTouserInput
  }

  export type ratingUncheckedCreateWithoutRideInput = {
    uuid?: string
    driverId: string
    userId: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
  }

  export type ratingCreateOrConnectWithoutRideInput = {
    where: ratingWhereUniqueInput
    create: XOR<ratingCreateWithoutRideInput, ratingUncheckedCreateWithoutRideInput>
  }

  export type ratingCreateManyRideInputEnvelope = {
    data: ratingCreateManyRideInput | ratingCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type ridestatusCreateWithoutRideInput = {
    uuid?: string
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
    user?: userCreateNestedOneWithoutRidestatusInput
    drivershift?: drivershiftCreateNestedOneWithoutRidestatusInput
  }

  export type ridestatusUncheckedCreateWithoutRideInput = {
    uuid?: string
    driverId?: string | null
    driverShiftId?: string | null
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
  }

  export type ridestatusCreateOrConnectWithoutRideInput = {
    where: ridestatusWhereUniqueInput
    create: XOR<ridestatusCreateWithoutRideInput, ridestatusUncheckedCreateWithoutRideInput>
  }

  export type ridestatusCreateManyRideInputEnvelope = {
    data: ridestatusCreateManyRideInput | ridestatusCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type messageUpsertWithWhereUniqueWithoutRideInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutRideInput, messageUncheckedUpdateWithoutRideInput>
    create: XOR<messageCreateWithoutRideInput, messageUncheckedCreateWithoutRideInput>
  }

  export type messageUpdateWithWhereUniqueWithoutRideInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutRideInput, messageUncheckedUpdateWithoutRideInput>
  }

  export type messageUpdateManyWithWhereWithoutRideInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutRideInput>
  }

  export type messageScalarWhereInput = {
    AND?: messageScalarWhereInput | messageScalarWhereInput[]
    OR?: messageScalarWhereInput[]
    NOT?: messageScalarWhereInput | messageScalarWhereInput[]
    uuid?: StringFilter<"message"> | string
    rideId?: StringFilter<"message"> | string
    senderId?: StringFilter<"message"> | string
    receiverId?: StringFilter<"message"> | string
    sendingTime?: DateTimeFilter<"message"> | Date | string
    message?: StringFilter<"message"> | string
  }

  export type ratingUpsertWithWhereUniqueWithoutRideInput = {
    where: ratingWhereUniqueInput
    update: XOR<ratingUpdateWithoutRideInput, ratingUncheckedUpdateWithoutRideInput>
    create: XOR<ratingCreateWithoutRideInput, ratingUncheckedCreateWithoutRideInput>
  }

  export type ratingUpdateWithWhereUniqueWithoutRideInput = {
    where: ratingWhereUniqueInput
    data: XOR<ratingUpdateWithoutRideInput, ratingUncheckedUpdateWithoutRideInput>
  }

  export type ratingUpdateManyWithWhereWithoutRideInput = {
    where: ratingScalarWhereInput
    data: XOR<ratingUpdateManyMutationInput, ratingUncheckedUpdateManyWithoutRideInput>
  }

  export type ratingScalarWhereInput = {
    AND?: ratingScalarWhereInput | ratingScalarWhereInput[]
    OR?: ratingScalarWhereInput[]
    NOT?: ratingScalarWhereInput | ratingScalarWhereInput[]
    uuid?: StringFilter<"rating"> | string
    rideId?: StringFilter<"rating"> | string
    driverId?: StringFilter<"rating"> | string
    userId?: StringFilter<"rating"> | string
    ratingComment?: StringNullableFilter<"rating"> | string | null
    ratingTag?: StringNullableFilter<"rating"> | string | null
    ratingValue?: IntFilter<"rating"> | number
    ratingTime?: DateTimeFilter<"rating"> | Date | string
  }

  export type ridestatusUpsertWithWhereUniqueWithoutRideInput = {
    where: ridestatusWhereUniqueInput
    update: XOR<ridestatusUpdateWithoutRideInput, ridestatusUncheckedUpdateWithoutRideInput>
    create: XOR<ridestatusCreateWithoutRideInput, ridestatusUncheckedCreateWithoutRideInput>
  }

  export type ridestatusUpdateWithWhereUniqueWithoutRideInput = {
    where: ridestatusWhereUniqueInput
    data: XOR<ridestatusUpdateWithoutRideInput, ridestatusUncheckedUpdateWithoutRideInput>
  }

  export type ridestatusUpdateManyWithWhereWithoutRideInput = {
    where: ridestatusScalarWhereInput
    data: XOR<ridestatusUpdateManyMutationInput, ridestatusUncheckedUpdateManyWithoutRideInput>
  }

  export type rideCreateWithoutRidestatusInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    phone: string
    seat?: number
    rideStartTime?: Date | string
    rideEndTime?: Date | string | null
    startingPoint: string
    destinationPoint: string
    distance?: number | null
    price?: number | null
    note?: string | null
    message?: messageCreateNestedManyWithoutRideInput
    rating?: ratingCreateNestedManyWithoutRideInput
  }

  export type rideUncheckedCreateWithoutRidestatusInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    phone: string
    seat?: number
    rideStartTime?: Date | string
    rideEndTime?: Date | string | null
    startingPoint: string
    destinationPoint: string
    distance?: number | null
    price?: number | null
    note?: string | null
    message?: messageUncheckedCreateNestedManyWithoutRideInput
    rating?: ratingUncheckedCreateNestedManyWithoutRideInput
  }

  export type rideCreateOrConnectWithoutRidestatusInput = {
    where: rideWhereUniqueInput
    create: XOR<rideCreateWithoutRidestatusInput, rideUncheckedCreateWithoutRidestatusInput>
  }

  export type userCreateWithoutRidestatusInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentCreateNestedManyWithoutUserInput
    customer?: customerCreateNestedManyWithoutUserInput
    driver?: driverCreateNestedManyWithoutUserInput
    drivershift?: drivershiftCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingCreateNestedManyWithoutUser_rating_userIdTouserInput
  }

  export type userUncheckedCreateWithoutRidestatusInput = {
    uuid?: string
    fullName: string
    gender?: string | null
    address?: string | null
    phone: string
    email?: string | null
    password: string
    role: string
    dob: Date | string
    cic: string
    avatar?: string
    createdAt?: Date | string | null
    call_call_userCallIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userCallIdTouserInput
    call_call_userAnswerIdTouser?: callUncheckedCreateNestedManyWithoutUser_call_userAnswerIdTouserInput
    callcenteragent?: callcenteragentUncheckedCreateNestedManyWithoutUserInput
    customer?: customerUncheckedCreateNestedManyWithoutUserInput
    driver?: driverUncheckedCreateNestedManyWithoutUserInput
    drivershift?: drivershiftUncheckedCreateNestedManyWithoutUserInput
    message_message_senderIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_senderIdTouserInput
    message_message_receiverIdTouser?: messageUncheckedCreateNestedManyWithoutUser_message_receiverIdTouserInput
    rating_rating_driverIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_driverIdTouserInput
    rating_rating_userIdTouser?: ratingUncheckedCreateNestedManyWithoutUser_rating_userIdTouserInput
  }

  export type userCreateOrConnectWithoutRidestatusInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRidestatusInput, userUncheckedCreateWithoutRidestatusInput>
  }

  export type drivershiftCreateWithoutRidestatusInput = {
    uuid?: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
    user: userCreateNestedOneWithoutDrivershiftInput
    car: carCreateNestedOneWithoutDrivershiftInput
  }

  export type drivershiftUncheckedCreateWithoutRidestatusInput = {
    uuid?: string
    driverId: string
    carId: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
  }

  export type drivershiftCreateOrConnectWithoutRidestatusInput = {
    where: drivershiftWhereUniqueInput
    create: XOR<drivershiftCreateWithoutRidestatusInput, drivershiftUncheckedCreateWithoutRidestatusInput>
  }

  export type rideUpsertWithoutRidestatusInput = {
    update: XOR<rideUpdateWithoutRidestatusInput, rideUncheckedUpdateWithoutRidestatusInput>
    create: XOR<rideCreateWithoutRidestatusInput, rideUncheckedCreateWithoutRidestatusInput>
    where?: rideWhereInput
  }

  export type rideUpdateToOneWithWhereWithoutRidestatusInput = {
    where?: rideWhereInput
    data: XOR<rideUpdateWithoutRidestatusInput, rideUncheckedUpdateWithoutRidestatusInput>
  }

  export type rideUpdateWithoutRidestatusInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    message?: messageUpdateManyWithoutRideNestedInput
    rating?: ratingUpdateManyWithoutRideNestedInput
  }

  export type rideUncheckedUpdateWithoutRidestatusInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    seat?: IntFieldUpdateOperationsInput | number
    rideStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    rideEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startingPoint?: StringFieldUpdateOperationsInput | string
    destinationPoint?: StringFieldUpdateOperationsInput | string
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    message?: messageUncheckedUpdateManyWithoutRideNestedInput
    rating?: ratingUncheckedUpdateManyWithoutRideNestedInput
  }

  export type userUpsertWithoutRidestatusInput = {
    update: XOR<userUpdateWithoutRidestatusInput, userUncheckedUpdateWithoutRidestatusInput>
    create: XOR<userCreateWithoutRidestatusInput, userUncheckedCreateWithoutRidestatusInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRidestatusInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRidestatusInput, userUncheckedUpdateWithoutRidestatusInput>
  }

  export type userUpdateWithoutRidestatusInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUpdateManyWithoutUserNestedInput
    customer?: customerUpdateManyWithoutUserNestedInput
    driver?: driverUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUpdateManyWithoutUser_rating_userIdTouserNestedInput
  }

  export type userUncheckedUpdateWithoutRidestatusInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    cic?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    call_call_userCallIdTouser?: callUncheckedUpdateManyWithoutUser_call_userCallIdTouserNestedInput
    call_call_userAnswerIdTouser?: callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserNestedInput
    callcenteragent?: callcenteragentUncheckedUpdateManyWithoutUserNestedInput
    customer?: customerUncheckedUpdateManyWithoutUserNestedInput
    driver?: driverUncheckedUpdateManyWithoutUserNestedInput
    drivershift?: drivershiftUncheckedUpdateManyWithoutUserNestedInput
    message_message_senderIdTouser?: messageUncheckedUpdateManyWithoutUser_message_senderIdTouserNestedInput
    message_message_receiverIdTouser?: messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserNestedInput
    rating_rating_driverIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserNestedInput
    rating_rating_userIdTouser?: ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserNestedInput
  }

  export type drivershiftUpsertWithoutRidestatusInput = {
    update: XOR<drivershiftUpdateWithoutRidestatusInput, drivershiftUncheckedUpdateWithoutRidestatusInput>
    create: XOR<drivershiftCreateWithoutRidestatusInput, drivershiftUncheckedCreateWithoutRidestatusInput>
    where?: drivershiftWhereInput
  }

  export type drivershiftUpdateToOneWithWhereWithoutRidestatusInput = {
    where?: drivershiftWhereInput
    data: XOR<drivershiftUpdateWithoutRidestatusInput, drivershiftUncheckedUpdateWithoutRidestatusInput>
  }

  export type drivershiftUpdateWithoutRidestatusInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutDrivershiftNestedInput
    car?: carUpdateOneRequiredWithoutDrivershiftNestedInput
  }

  export type drivershiftUncheckedUpdateWithoutRidestatusInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type callCreateWithoutUser_call_userCallIdTouserInput = {
    uuid?: string
    beginCallingTime?: Date | string
    endCallingTime?: Date | string | null
    callingStatus: string
    user_call_userAnswerIdTouser: userCreateNestedOneWithoutCall_call_userAnswerIdTouserInput
  }

  export type callUncheckedCreateWithoutUser_call_userCallIdTouserInput = {
    uuid?: string
    userAnswerId: string
    beginCallingTime?: Date | string
    endCallingTime?: Date | string | null
    callingStatus: string
  }

  export type callCreateOrConnectWithoutUser_call_userCallIdTouserInput = {
    where: callWhereUniqueInput
    create: XOR<callCreateWithoutUser_call_userCallIdTouserInput, callUncheckedCreateWithoutUser_call_userCallIdTouserInput>
  }

  export type callCreateManyUser_call_userCallIdTouserInputEnvelope = {
    data: callCreateManyUser_call_userCallIdTouserInput | callCreateManyUser_call_userCallIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type callCreateWithoutUser_call_userAnswerIdTouserInput = {
    uuid?: string
    beginCallingTime?: Date | string
    endCallingTime?: Date | string | null
    callingStatus: string
    user_call_userCallIdTouser: userCreateNestedOneWithoutCall_call_userCallIdTouserInput
  }

  export type callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput = {
    uuid?: string
    userCallId: string
    beginCallingTime?: Date | string
    endCallingTime?: Date | string | null
    callingStatus: string
  }

  export type callCreateOrConnectWithoutUser_call_userAnswerIdTouserInput = {
    where: callWhereUniqueInput
    create: XOR<callCreateWithoutUser_call_userAnswerIdTouserInput, callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput>
  }

  export type callCreateManyUser_call_userAnswerIdTouserInputEnvelope = {
    data: callCreateManyUser_call_userAnswerIdTouserInput | callCreateManyUser_call_userAnswerIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type callcenteragentCreateWithoutUserInput = {
    uuid?: string
    state?: string
  }

  export type callcenteragentUncheckedCreateWithoutUserInput = {
    uuid?: string
    state?: string
  }

  export type callcenteragentCreateOrConnectWithoutUserInput = {
    where: callcenteragentWhereUniqueInput
    create: XOR<callcenteragentCreateWithoutUserInput, callcenteragentUncheckedCreateWithoutUserInput>
  }

  export type callcenteragentCreateManyUserInputEnvelope = {
    data: callcenteragentCreateManyUserInput | callcenteragentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type customerCreateWithoutUserInput = {
    uuid?: string
    state?: string
  }

  export type customerUncheckedCreateWithoutUserInput = {
    uuid?: string
    state?: string
  }

  export type customerCreateOrConnectWithoutUserInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput>
  }

  export type customerCreateManyUserInputEnvelope = {
    data: customerCreateManyUserInput | customerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type driverCreateWithoutUserInput = {
    uuid?: string
    drivingLicenceNumber: string
    expiryDate: Date | string
    state?: string
  }

  export type driverUncheckedCreateWithoutUserInput = {
    uuid?: string
    drivingLicenceNumber: string
    expiryDate: Date | string
    state?: string
  }

  export type driverCreateOrConnectWithoutUserInput = {
    where: driverWhereUniqueInput
    create: XOR<driverCreateWithoutUserInput, driverUncheckedCreateWithoutUserInput>
  }

  export type driverCreateManyUserInputEnvelope = {
    data: driverCreateManyUserInput | driverCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type drivershiftCreateWithoutUserInput = {
    uuid?: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
    car: carCreateNestedOneWithoutDrivershiftInput
    ridestatus?: ridestatusCreateNestedManyWithoutDrivershiftInput
  }

  export type drivershiftUncheckedCreateWithoutUserInput = {
    uuid?: string
    carId: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
    ridestatus?: ridestatusUncheckedCreateNestedManyWithoutDrivershiftInput
  }

  export type drivershiftCreateOrConnectWithoutUserInput = {
    where: drivershiftWhereUniqueInput
    create: XOR<drivershiftCreateWithoutUserInput, drivershiftUncheckedCreateWithoutUserInput>
  }

  export type drivershiftCreateManyUserInputEnvelope = {
    data: drivershiftCreateManyUserInput | drivershiftCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutUser_message_senderIdTouserInput = {
    uuid?: string
    sendingTime?: Date | string
    message: string
    ride: rideCreateNestedOneWithoutMessageInput
    user_message_receiverIdTouser: userCreateNestedOneWithoutMessage_message_receiverIdTouserInput
  }

  export type messageUncheckedCreateWithoutUser_message_senderIdTouserInput = {
    uuid?: string
    rideId: string
    receiverId: string
    sendingTime?: Date | string
    message: string
  }

  export type messageCreateOrConnectWithoutUser_message_senderIdTouserInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutUser_message_senderIdTouserInput, messageUncheckedCreateWithoutUser_message_senderIdTouserInput>
  }

  export type messageCreateManyUser_message_senderIdTouserInputEnvelope = {
    data: messageCreateManyUser_message_senderIdTouserInput | messageCreateManyUser_message_senderIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutUser_message_receiverIdTouserInput = {
    uuid?: string
    sendingTime?: Date | string
    message: string
    ride: rideCreateNestedOneWithoutMessageInput
    user_message_senderIdTouser: userCreateNestedOneWithoutMessage_message_senderIdTouserInput
  }

  export type messageUncheckedCreateWithoutUser_message_receiverIdTouserInput = {
    uuid?: string
    rideId: string
    senderId: string
    sendingTime?: Date | string
    message: string
  }

  export type messageCreateOrConnectWithoutUser_message_receiverIdTouserInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutUser_message_receiverIdTouserInput, messageUncheckedCreateWithoutUser_message_receiverIdTouserInput>
  }

  export type messageCreateManyUser_message_receiverIdTouserInputEnvelope = {
    data: messageCreateManyUser_message_receiverIdTouserInput | messageCreateManyUser_message_receiverIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type ratingCreateWithoutUser_rating_driverIdTouserInput = {
    uuid?: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
    ride: rideCreateNestedOneWithoutRatingInput
    user_rating_userIdTouser: userCreateNestedOneWithoutRating_rating_userIdTouserInput
  }

  export type ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput = {
    uuid?: string
    rideId: string
    userId: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
  }

  export type ratingCreateOrConnectWithoutUser_rating_driverIdTouserInput = {
    where: ratingWhereUniqueInput
    create: XOR<ratingCreateWithoutUser_rating_driverIdTouserInput, ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput>
  }

  export type ratingCreateManyUser_rating_driverIdTouserInputEnvelope = {
    data: ratingCreateManyUser_rating_driverIdTouserInput | ratingCreateManyUser_rating_driverIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type ratingCreateWithoutUser_rating_userIdTouserInput = {
    uuid?: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
    ride: rideCreateNestedOneWithoutRatingInput
    user_rating_driverIdTouser: userCreateNestedOneWithoutRating_rating_driverIdTouserInput
  }

  export type ratingUncheckedCreateWithoutUser_rating_userIdTouserInput = {
    uuid?: string
    rideId: string
    driverId: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
  }

  export type ratingCreateOrConnectWithoutUser_rating_userIdTouserInput = {
    where: ratingWhereUniqueInput
    create: XOR<ratingCreateWithoutUser_rating_userIdTouserInput, ratingUncheckedCreateWithoutUser_rating_userIdTouserInput>
  }

  export type ratingCreateManyUser_rating_userIdTouserInputEnvelope = {
    data: ratingCreateManyUser_rating_userIdTouserInput | ratingCreateManyUser_rating_userIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type ridestatusCreateWithoutUserInput = {
    uuid?: string
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
    ride: rideCreateNestedOneWithoutRidestatusInput
    drivershift?: drivershiftCreateNestedOneWithoutRidestatusInput
  }

  export type ridestatusUncheckedCreateWithoutUserInput = {
    uuid?: string
    rideId: string
    driverShiftId?: string | null
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
  }

  export type ridestatusCreateOrConnectWithoutUserInput = {
    where: ridestatusWhereUniqueInput
    create: XOR<ridestatusCreateWithoutUserInput, ridestatusUncheckedCreateWithoutUserInput>
  }

  export type ridestatusCreateManyUserInputEnvelope = {
    data: ridestatusCreateManyUserInput | ridestatusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type callUpsertWithWhereUniqueWithoutUser_call_userCallIdTouserInput = {
    where: callWhereUniqueInput
    update: XOR<callUpdateWithoutUser_call_userCallIdTouserInput, callUncheckedUpdateWithoutUser_call_userCallIdTouserInput>
    create: XOR<callCreateWithoutUser_call_userCallIdTouserInput, callUncheckedCreateWithoutUser_call_userCallIdTouserInput>
  }

  export type callUpdateWithWhereUniqueWithoutUser_call_userCallIdTouserInput = {
    where: callWhereUniqueInput
    data: XOR<callUpdateWithoutUser_call_userCallIdTouserInput, callUncheckedUpdateWithoutUser_call_userCallIdTouserInput>
  }

  export type callUpdateManyWithWhereWithoutUser_call_userCallIdTouserInput = {
    where: callScalarWhereInput
    data: XOR<callUpdateManyMutationInput, callUncheckedUpdateManyWithoutUser_call_userCallIdTouserInput>
  }

  export type callScalarWhereInput = {
    AND?: callScalarWhereInput | callScalarWhereInput[]
    OR?: callScalarWhereInput[]
    NOT?: callScalarWhereInput | callScalarWhereInput[]
    uuid?: StringFilter<"call"> | string
    userCallId?: StringFilter<"call"> | string
    userAnswerId?: StringFilter<"call"> | string
    beginCallingTime?: DateTimeFilter<"call"> | Date | string
    endCallingTime?: DateTimeNullableFilter<"call"> | Date | string | null
    callingStatus?: StringFilter<"call"> | string
  }

  export type callUpsertWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput = {
    where: callWhereUniqueInput
    update: XOR<callUpdateWithoutUser_call_userAnswerIdTouserInput, callUncheckedUpdateWithoutUser_call_userAnswerIdTouserInput>
    create: XOR<callCreateWithoutUser_call_userAnswerIdTouserInput, callUncheckedCreateWithoutUser_call_userAnswerIdTouserInput>
  }

  export type callUpdateWithWhereUniqueWithoutUser_call_userAnswerIdTouserInput = {
    where: callWhereUniqueInput
    data: XOR<callUpdateWithoutUser_call_userAnswerIdTouserInput, callUncheckedUpdateWithoutUser_call_userAnswerIdTouserInput>
  }

  export type callUpdateManyWithWhereWithoutUser_call_userAnswerIdTouserInput = {
    where: callScalarWhereInput
    data: XOR<callUpdateManyMutationInput, callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserInput>
  }

  export type callcenteragentUpsertWithWhereUniqueWithoutUserInput = {
    where: callcenteragentWhereUniqueInput
    update: XOR<callcenteragentUpdateWithoutUserInput, callcenteragentUncheckedUpdateWithoutUserInput>
    create: XOR<callcenteragentCreateWithoutUserInput, callcenteragentUncheckedCreateWithoutUserInput>
  }

  export type callcenteragentUpdateWithWhereUniqueWithoutUserInput = {
    where: callcenteragentWhereUniqueInput
    data: XOR<callcenteragentUpdateWithoutUserInput, callcenteragentUncheckedUpdateWithoutUserInput>
  }

  export type callcenteragentUpdateManyWithWhereWithoutUserInput = {
    where: callcenteragentScalarWhereInput
    data: XOR<callcenteragentUpdateManyMutationInput, callcenteragentUncheckedUpdateManyWithoutUserInput>
  }

  export type callcenteragentScalarWhereInput = {
    AND?: callcenteragentScalarWhereInput | callcenteragentScalarWhereInput[]
    OR?: callcenteragentScalarWhereInput[]
    NOT?: callcenteragentScalarWhereInput | callcenteragentScalarWhereInput[]
    uuid?: StringFilter<"callcenteragent"> | string
    userId?: StringFilter<"callcenteragent"> | string
    state?: StringFilter<"callcenteragent"> | string
  }

  export type customerUpsertWithWhereUniqueWithoutUserInput = {
    where: customerWhereUniqueInput
    update: XOR<customerUpdateWithoutUserInput, customerUncheckedUpdateWithoutUserInput>
    create: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput>
  }

  export type customerUpdateWithWhereUniqueWithoutUserInput = {
    where: customerWhereUniqueInput
    data: XOR<customerUpdateWithoutUserInput, customerUncheckedUpdateWithoutUserInput>
  }

  export type customerUpdateManyWithWhereWithoutUserInput = {
    where: customerScalarWhereInput
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyWithoutUserInput>
  }

  export type customerScalarWhereInput = {
    AND?: customerScalarWhereInput | customerScalarWhereInput[]
    OR?: customerScalarWhereInput[]
    NOT?: customerScalarWhereInput | customerScalarWhereInput[]
    uuid?: StringFilter<"customer"> | string
    userId?: StringNullableFilter<"customer"> | string | null
    state?: StringFilter<"customer"> | string
  }

  export type driverUpsertWithWhereUniqueWithoutUserInput = {
    where: driverWhereUniqueInput
    update: XOR<driverUpdateWithoutUserInput, driverUncheckedUpdateWithoutUserInput>
    create: XOR<driverCreateWithoutUserInput, driverUncheckedCreateWithoutUserInput>
  }

  export type driverUpdateWithWhereUniqueWithoutUserInput = {
    where: driverWhereUniqueInput
    data: XOR<driverUpdateWithoutUserInput, driverUncheckedUpdateWithoutUserInput>
  }

  export type driverUpdateManyWithWhereWithoutUserInput = {
    where: driverScalarWhereInput
    data: XOR<driverUpdateManyMutationInput, driverUncheckedUpdateManyWithoutUserInput>
  }

  export type driverScalarWhereInput = {
    AND?: driverScalarWhereInput | driverScalarWhereInput[]
    OR?: driverScalarWhereInput[]
    NOT?: driverScalarWhereInput | driverScalarWhereInput[]
    uuid?: StringFilter<"driver"> | string
    userId?: StringFilter<"driver"> | string
    drivingLicenceNumber?: StringFilter<"driver"> | string
    expiryDate?: DateTimeFilter<"driver"> | Date | string
    state?: StringFilter<"driver"> | string
  }

  export type drivershiftUpsertWithWhereUniqueWithoutUserInput = {
    where: drivershiftWhereUniqueInput
    update: XOR<drivershiftUpdateWithoutUserInput, drivershiftUncheckedUpdateWithoutUserInput>
    create: XOR<drivershiftCreateWithoutUserInput, drivershiftUncheckedCreateWithoutUserInput>
  }

  export type drivershiftUpdateWithWhereUniqueWithoutUserInput = {
    where: drivershiftWhereUniqueInput
    data: XOR<drivershiftUpdateWithoutUserInput, drivershiftUncheckedUpdateWithoutUserInput>
  }

  export type drivershiftUpdateManyWithWhereWithoutUserInput = {
    where: drivershiftScalarWhereInput
    data: XOR<drivershiftUpdateManyMutationInput, drivershiftUncheckedUpdateManyWithoutUserInput>
  }

  export type messageUpsertWithWhereUniqueWithoutUser_message_senderIdTouserInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutUser_message_senderIdTouserInput, messageUncheckedUpdateWithoutUser_message_senderIdTouserInput>
    create: XOR<messageCreateWithoutUser_message_senderIdTouserInput, messageUncheckedCreateWithoutUser_message_senderIdTouserInput>
  }

  export type messageUpdateWithWhereUniqueWithoutUser_message_senderIdTouserInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutUser_message_senderIdTouserInput, messageUncheckedUpdateWithoutUser_message_senderIdTouserInput>
  }

  export type messageUpdateManyWithWhereWithoutUser_message_senderIdTouserInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutUser_message_senderIdTouserInput>
  }

  export type messageUpsertWithWhereUniqueWithoutUser_message_receiverIdTouserInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutUser_message_receiverIdTouserInput, messageUncheckedUpdateWithoutUser_message_receiverIdTouserInput>
    create: XOR<messageCreateWithoutUser_message_receiverIdTouserInput, messageUncheckedCreateWithoutUser_message_receiverIdTouserInput>
  }

  export type messageUpdateWithWhereUniqueWithoutUser_message_receiverIdTouserInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutUser_message_receiverIdTouserInput, messageUncheckedUpdateWithoutUser_message_receiverIdTouserInput>
  }

  export type messageUpdateManyWithWhereWithoutUser_message_receiverIdTouserInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserInput>
  }

  export type ratingUpsertWithWhereUniqueWithoutUser_rating_driverIdTouserInput = {
    where: ratingWhereUniqueInput
    update: XOR<ratingUpdateWithoutUser_rating_driverIdTouserInput, ratingUncheckedUpdateWithoutUser_rating_driverIdTouserInput>
    create: XOR<ratingCreateWithoutUser_rating_driverIdTouserInput, ratingUncheckedCreateWithoutUser_rating_driverIdTouserInput>
  }

  export type ratingUpdateWithWhereUniqueWithoutUser_rating_driverIdTouserInput = {
    where: ratingWhereUniqueInput
    data: XOR<ratingUpdateWithoutUser_rating_driverIdTouserInput, ratingUncheckedUpdateWithoutUser_rating_driverIdTouserInput>
  }

  export type ratingUpdateManyWithWhereWithoutUser_rating_driverIdTouserInput = {
    where: ratingScalarWhereInput
    data: XOR<ratingUpdateManyMutationInput, ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserInput>
  }

  export type ratingUpsertWithWhereUniqueWithoutUser_rating_userIdTouserInput = {
    where: ratingWhereUniqueInput
    update: XOR<ratingUpdateWithoutUser_rating_userIdTouserInput, ratingUncheckedUpdateWithoutUser_rating_userIdTouserInput>
    create: XOR<ratingCreateWithoutUser_rating_userIdTouserInput, ratingUncheckedCreateWithoutUser_rating_userIdTouserInput>
  }

  export type ratingUpdateWithWhereUniqueWithoutUser_rating_userIdTouserInput = {
    where: ratingWhereUniqueInput
    data: XOR<ratingUpdateWithoutUser_rating_userIdTouserInput, ratingUncheckedUpdateWithoutUser_rating_userIdTouserInput>
  }

  export type ratingUpdateManyWithWhereWithoutUser_rating_userIdTouserInput = {
    where: ratingScalarWhereInput
    data: XOR<ratingUpdateManyMutationInput, ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserInput>
  }

  export type ridestatusUpsertWithWhereUniqueWithoutUserInput = {
    where: ridestatusWhereUniqueInput
    update: XOR<ridestatusUpdateWithoutUserInput, ridestatusUncheckedUpdateWithoutUserInput>
    create: XOR<ridestatusCreateWithoutUserInput, ridestatusUncheckedCreateWithoutUserInput>
  }

  export type ridestatusUpdateWithWhereUniqueWithoutUserInput = {
    where: ridestatusWhereUniqueInput
    data: XOR<ridestatusUpdateWithoutUserInput, ridestatusUncheckedUpdateWithoutUserInput>
  }

  export type ridestatusUpdateManyWithWhereWithoutUserInput = {
    where: ridestatusScalarWhereInput
    data: XOR<ridestatusUpdateManyMutationInput, ridestatusUncheckedUpdateManyWithoutUserInput>
  }

  export type drivershiftCreateManyCarInput = {
    uuid?: string
    driverId: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
  }

  export type drivershiftUpdateWithoutCarInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutDrivershiftNestedInput
    ridestatus?: ridestatusUpdateManyWithoutDrivershiftNestedInput
  }

  export type drivershiftUncheckedUpdateWithoutCarInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ridestatus?: ridestatusUncheckedUpdateManyWithoutDrivershiftNestedInput
  }

  export type drivershiftUncheckedUpdateManyWithoutCarInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ridestatusCreateManyDrivershiftInput = {
    uuid?: string
    rideId: string
    driverId?: string | null
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
  }

  export type ridestatusUpdateWithoutDrivershiftInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
    ride?: rideUpdateOneRequiredWithoutRidestatusNestedInput
    user?: userUpdateOneWithoutRidestatusNestedInput
  }

  export type ridestatusUncheckedUpdateWithoutDrivershiftInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ridestatusUncheckedUpdateManyWithoutDrivershiftInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messageCreateManyRideInput = {
    uuid?: string
    senderId: string
    receiverId: string
    sendingTime?: Date | string
    message: string
  }

  export type ratingCreateManyRideInput = {
    uuid?: string
    driverId: string
    userId: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
  }

  export type ridestatusCreateManyRideInput = {
    uuid?: string
    driverId?: string | null
    driverShiftId?: string | null
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
  }

  export type messageUpdateWithoutRideInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    user_message_senderIdTouser?: userUpdateOneRequiredWithoutMessage_message_senderIdTouserNestedInput
    user_message_receiverIdTouser?: userUpdateOneRequiredWithoutMessage_message_receiverIdTouserNestedInput
  }

  export type messageUncheckedUpdateWithoutRideInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type messageUncheckedUpdateManyWithoutRideInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ratingUpdateWithoutRideInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    user_rating_driverIdTouser?: userUpdateOneRequiredWithoutRating_rating_driverIdTouserNestedInput
    user_rating_userIdTouser?: userUpdateOneRequiredWithoutRating_rating_userIdTouserNestedInput
  }

  export type ratingUncheckedUpdateWithoutRideInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingUncheckedUpdateManyWithoutRideInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ridestatusUpdateWithoutRideInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneWithoutRidestatusNestedInput
    drivershift?: drivershiftUpdateOneWithoutRidestatusNestedInput
  }

  export type ridestatusUncheckedUpdateWithoutRideInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ridestatusUncheckedUpdateManyWithoutRideInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    driverShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type callCreateManyUser_call_userCallIdTouserInput = {
    uuid?: string
    userAnswerId: string
    beginCallingTime?: Date | string
    endCallingTime?: Date | string | null
    callingStatus: string
  }

  export type callCreateManyUser_call_userAnswerIdTouserInput = {
    uuid?: string
    userCallId: string
    beginCallingTime?: Date | string
    endCallingTime?: Date | string | null
    callingStatus: string
  }

  export type callcenteragentCreateManyUserInput = {
    uuid?: string
    state?: string
  }

  export type customerCreateManyUserInput = {
    uuid?: string
    state?: string
  }

  export type driverCreateManyUserInput = {
    uuid?: string
    drivingLicenceNumber: string
    expiryDate: Date | string
    state?: string
  }

  export type drivershiftCreateManyUserInput = {
    uuid?: string
    carId: string
    shiftStartTime: Date | string
    shiftEndTime: Date | string
    createdAt?: Date | string | null
  }

  export type messageCreateManyUser_message_senderIdTouserInput = {
    uuid?: string
    rideId: string
    receiverId: string
    sendingTime?: Date | string
    message: string
  }

  export type messageCreateManyUser_message_receiverIdTouserInput = {
    uuid?: string
    rideId: string
    senderId: string
    sendingTime?: Date | string
    message: string
  }

  export type ratingCreateManyUser_rating_driverIdTouserInput = {
    uuid?: string
    rideId: string
    userId: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
  }

  export type ratingCreateManyUser_rating_userIdTouserInput = {
    uuid?: string
    rideId: string
    driverId: string
    ratingComment?: string | null
    ratingTag?: string | null
    ratingValue: number
    ratingTime?: Date | string
  }

  export type ridestatusCreateManyUserInput = {
    uuid?: string
    rideId: string
    driverShiftId?: string | null
    state?: string
    stateTime?: Date | string
    stateDetail?: string | null
  }

  export type callUpdateWithoutUser_call_userCallIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
    user_call_userAnswerIdTouser?: userUpdateOneRequiredWithoutCall_call_userAnswerIdTouserNestedInput
  }

  export type callUncheckedUpdateWithoutUser_call_userCallIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userAnswerId?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type callUncheckedUpdateManyWithoutUser_call_userCallIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userAnswerId?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type callUpdateWithoutUser_call_userAnswerIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
    user_call_userCallIdTouser?: userUpdateOneRequiredWithoutCall_call_userCallIdTouserNestedInput
  }

  export type callUncheckedUpdateWithoutUser_call_userAnswerIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userCallId?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type callUncheckedUpdateManyWithoutUser_call_userAnswerIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userCallId?: StringFieldUpdateOperationsInput | string
    beginCallingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endCallingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type callcenteragentUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type callcenteragentUncheckedUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type callcenteragentUncheckedUpdateManyWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type customerUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type customerUncheckedUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type customerUncheckedUpdateManyWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type driverUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    drivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type driverUncheckedUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    drivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type driverUncheckedUpdateManyWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    drivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type drivershiftUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    car?: carUpdateOneRequiredWithoutDrivershiftNestedInput
    ridestatus?: ridestatusUpdateManyWithoutDrivershiftNestedInput
  }

  export type drivershiftUncheckedUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    carId?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ridestatus?: ridestatusUncheckedUpdateManyWithoutDrivershiftNestedInput
  }

  export type drivershiftUncheckedUpdateManyWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    carId?: StringFieldUpdateOperationsInput | string
    shiftStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUpdateWithoutUser_message_senderIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    ride?: rideUpdateOneRequiredWithoutMessageNestedInput
    user_message_receiverIdTouser?: userUpdateOneRequiredWithoutMessage_message_receiverIdTouserNestedInput
  }

  export type messageUncheckedUpdateWithoutUser_message_senderIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type messageUncheckedUpdateManyWithoutUser_message_senderIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type messageUpdateWithoutUser_message_receiverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    ride?: rideUpdateOneRequiredWithoutMessageNestedInput
    user_message_senderIdTouser?: userUpdateOneRequiredWithoutMessage_message_senderIdTouserNestedInput
  }

  export type messageUncheckedUpdateWithoutUser_message_receiverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type messageUncheckedUpdateManyWithoutUser_message_receiverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    sendingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ratingUpdateWithoutUser_rating_driverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: rideUpdateOneRequiredWithoutRatingNestedInput
    user_rating_userIdTouser?: userUpdateOneRequiredWithoutRating_rating_userIdTouserNestedInput
  }

  export type ratingUncheckedUpdateWithoutUser_rating_driverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingUncheckedUpdateManyWithoutUser_rating_driverIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingUpdateWithoutUser_rating_userIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: rideUpdateOneRequiredWithoutRatingNestedInput
    user_rating_driverIdTouser?: userUpdateOneRequiredWithoutRating_rating_driverIdTouserNestedInput
  }

  export type ratingUncheckedUpdateWithoutUser_rating_userIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingUncheckedUpdateManyWithoutUser_rating_userIdTouserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    ratingComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingTag?: NullableStringFieldUpdateOperationsInput | string | null
    ratingValue?: IntFieldUpdateOperationsInput | number
    ratingTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ridestatusUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
    ride?: rideUpdateOneRequiredWithoutRidestatusNestedInput
    drivershift?: drivershiftUpdateOneWithoutRidestatusNestedInput
  }

  export type ridestatusUncheckedUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ridestatusUncheckedUpdateManyWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    driverShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    stateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    stateDetail?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CarCountOutputTypeDefaultArgs instead
     */
    export type CarCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DrivershiftCountOutputTypeDefaultArgs instead
     */
    export type DrivershiftCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DrivershiftCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RideCountOutputTypeDefaultArgs instead
     */
    export type RideCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RideCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use callDefaultArgs instead
     */
    export type callArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = callDefaultArgs<ExtArgs>
    /**
     * @deprecated Use callcenteragentDefaultArgs instead
     */
    export type callcenteragentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = callcenteragentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use carDefaultArgs instead
     */
    export type carArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = carDefaultArgs<ExtArgs>
    /**
     * @deprecated Use customerDefaultArgs instead
     */
    export type customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = customerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use driverDefaultArgs instead
     */
    export type driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = driverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use drivershiftDefaultArgs instead
     */
    export type drivershiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = drivershiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use messageDefaultArgs instead
     */
    export type messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = messageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ratingDefaultArgs instead
     */
    export type ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ratingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rideDefaultArgs instead
     */
    export type rideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ridestatusDefaultArgs instead
     */
    export type ridestatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ridestatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}